<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8' />
  <link rel="shortcut icon" type="image/x-icon" href="https://diycode.b0.upaiyun.com/assets/favicon-bd135558698197f509ada06695c03a4f458f0077fa476f9a4e7ba9664f3dc55f.ico" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
  <meta name="apple-mobile-web-app-capable" content="no">
  <meta content='True' name='HandheldFriendly' />
    <meta http-equiv="X-Frame-Options" content="ALLOW-FROM https://www.bilibili.com">  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>
    从源码角度看Handler － 小专栏
  </title>
  <meta name="keywords" content="" />
  <meta name="description" content="从源码角度看 Android - @RickAi - 简介 Handler这套线程异步通信框架在Android中的地位是不亚于Binder的，因为其基础设计简单、涉及的知识面广、业务使用场景多等原因，十分适合应用层的初中级的工程师进行深入学习  这篇文章中我将分析H..." />
  <link rel="stylesheet" media="screen" href="https://diycode.b0.upaiyun.com/assets/application-f734c62f1bbd70be618525ecbb2c33b87f167b531ce866a302f1e2283655defe.css" />
  <link rel="stylesheet" media="screen" href="https://diycode.b0.upaiyun.com/assets/base-2b98779741767449024e9452dec1c559566c0fc6b0b91903e25fd401bd554e60.css" />
  <script src="https://diycode.b0.upaiyun.com/assets/application-99fe0210a6993e720c65ce7e52be1de5941f2ac657e45a4915ac9a715d9113a6.js"></script>
  <script src="https://diycode.b0.upaiyun.com/assets/lib/showdown_toc-ebb63501ea44121d364fd5bbf368e6680552896b0b1250218e5bfcd6c6e75fac.js"></script>
  <script src="https://diycode.b0.upaiyun.com/assets/lib/flowchart-e67c581916393cef0114623cdb6386ae4d590f549b3a4fe6d4a5b65930200f67.js"></script>
  <script src="https://diycode.b0.upaiyun.com/assets/lib/mermaid-87c4a8b71bd9cec95ceb3601f3c343505dcd851ccf412682982e9d530887eaca.js"></script>


  <meta name="action-cable-url" content="/cable" />
    <script src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_SVG"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true }, TeX: { equationNumbers: { autoNumber: "AMS" } }, messageStyle: "none", SVG: { blacker: 1 }});
    </script>
    <link rel="dns-prefetch" href="//cdn.bootcss.com" />
    <link rel="dns-prefetch" href="//cdn.mathjax.org" />
    <script src="https://diycode.b0.upaiyun.com/assets/lib/raphael-73fc121fcba5dc93ab67fbe3a44329411937f2f432ec705a3e2c337ad2d4d576.js"></script>
</head>
<body data-current-user-id="76688" class="  "  >
  <script type="text/javascript">
    $(window).unbind('scroll');
  </script>

  <div class="xzl-site-main " id="container" data-page-title="从源码角度看Handler － 小专栏" data-page-description="简介 Handler这套线程异步通信框架在Android中的地位是不亚于Binder的，因为其基础设计简单、涉及的知识面广">
    <img class="share_page_img hidden" src="https://diycode.b0.upaiyun.com/assets/share_logo-a15dd98a7d6b22923eb2eea3c246043ad69ebeec10682ddabc27854620f2cb9c.png" alt="Share logo" />
    <div class="xzl-main-container">
        <div class="xzl-metabar-wrapper  with-cover">
          <div class="metabar">
            <a href="/", class="xzl-logo-link">
                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="142px" height="52px" viewBox="0 0 142 52" version="1.1" class="xzl-logo">
    <!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs>
        <path d="M63.853,17.315 L65.037,17.315 C65.222,17.315 65.347,17.505 65.276,17.676 L59.733,30.84 C59.692,30.938 59.597,30.999 59.493,30.999 L58.311,30.999 C58.126,30.999 58,30.811 58.071,30.639 L63.614,17.473 C63.654,17.378 63.75,17.315 63.853,17.315 Z M76.879,17.315 L78.072,17.315 C78.175,17.315 78.268,17.374 78.31,17.47 L84.519,31.44 C84.595,31.612 84.469,31.804 84.281,31.804 L83.088,31.804 C82.986,31.804 82.892,31.744 82.851,31.651 L76.642,17.68 C76.567,17.508 76.693,17.315 76.879,17.315 Z M116.445,21.341 L117.548,21.341 C117.708,21.341 117.83,21.482 117.804,21.64 L116.306,31.316 C116.287,31.443 116.177,31.536 116.051,31.536 L114.946,31.536 C114.788,31.536 114.666,31.395 114.69,31.236 L116.188,21.56 C116.208,21.433 116.317,21.341 116.445,21.341 Z M136.192,11.948 L137.386,11.948 C137.572,11.948 137.698,12.142 137.623,12.314 L135.265,17.622 C135.188,17.794 135.314,17.987 135.501,17.987 L139.625,17.987 C139.77,17.987 139.887,18.103 139.887,18.248 L139.887,19.337 C139.887,19.48 139.77,19.596 139.625,19.596 L125.583,19.596 C125.439,19.596 125.323,19.48 125.323,19.337 L125.323,18.248 C125.323,18.103 125.439,17.987 125.583,17.987 L128.527,17.987 C128.717,17.987 128.843,17.794 128.766,17.622 L126.533,12.598 C126.456,12.425 126.582,12.232 126.772,12.232 L127.963,12.232 C128.065,12.232 128.158,12.294 128.201,12.387 L130.621,17.832 C130.662,17.927 130.757,17.987 130.859,17.987 L133.17,17.987 C133.273,17.987 133.367,17.927 133.408,17.832 L135.954,12.102 C135.996,12.008 136.09,11.948 136.192,11.948 Z M126.658,26.037 L138.552,26.037 C138.696,26.037 138.811,26.154 138.811,26.297 L138.811,27.387 C138.811,27.531 138.696,27.648 138.552,27.648 L126.658,27.648 C126.513,27.648 126.397,27.531 126.397,27.387 L126.397,26.297 C126.397,26.154 126.513,26.037 126.658,26.037 Z M124.271,35.566 L140.94,35.566 C141.082,35.566 141.199,35.682 141.199,35.827 L141.199,36.917 C141.199,37.06 141.082,37.178 140.94,37.178 L124.271,37.178 C124.126,37.178 124.01,37.06 124.01,36.917 L124.01,35.827 C124.01,35.682 124.126,35.566 124.271,35.566 Z M96.934,11.411 L98.027,11.411 C98.167,11.411 98.283,11.522 98.286,11.662 C98.308,12.369 98.3,13.664 98.102,15.278 C98.082,15.432 98.203,15.572 98.358,15.572 L109.382,15.572 C109.525,15.572 109.642,15.689 109.642,15.831 L109.642,16.921 C109.642,17.066 109.525,17.182 109.382,17.182 L98.005,17.182 C97.881,17.182 97.776,17.267 97.75,17.386 C97.537,18.404 97.241,19.485 96.837,20.586 C96.776,20.757 96.898,20.938 97.079,20.938 L110.992,20.938 C111.136,20.938 111.252,21.054 111.252,21.199 L111.252,22.287 C111.252,22.431 111.136,22.548 110.992,22.548 L96.162,22.548 C96.066,22.548 95.977,22.603 95.933,22.691 C95.344,23.87 94.609,25.039 93.695,26.145 C93.555,26.316 93.67,26.574 93.893,26.574 L107.661,26.574 C107.805,26.574 107.92,26.69 107.92,26.832 L107.92,28.181 L107.921,28.182 L107.92,28.182 L107.919,28.182 L100.642,33.953 C100.477,34.085 100.527,34.347 100.731,34.408 L105.856,35.898 C105.966,35.93 106.042,36.033 106.042,36.148 L106.042,37.283 C106.042,37.456 105.875,37.581 105.71,37.533 L89.324,32.765 C89.213,32.734 89.138,32.632 89.138,32.518 L89.138,31.381 C89.138,31.207 89.304,31.083 89.471,31.132 L98.223,33.678 C98.304,33.702 98.391,33.684 98.456,33.632 L104.743,28.649 C104.936,28.495 104.827,28.182 104.581,28.182 L91.349,28.182 C91.204,28.182 91.087,28.067 91.087,27.922 L91.087,26.684 C91.087,26.613 91.118,26.545 91.168,26.497 C92.319,25.406 93.232,24.19 93.954,22.936 C94.054,22.763 93.925,22.548 93.727,22.548 L85.909,22.548 C85.766,22.548 85.649,22.431 85.649,22.287 L85.649,21.199 C85.649,21.054 85.766,20.938 85.909,20.938 L94.772,20.938 C94.876,20.938 94.974,20.873 95.014,20.776 C95.474,19.658 95.808,18.547 96.05,17.498 C96.089,17.336 95.963,17.182 95.795,17.182 L87.251,17.182 C87.107,17.182 86.99,17.066 86.99,16.921 L86.99,15.831 C86.99,15.689 87.107,15.572 87.251,15.572 L96.188,15.572 C96.318,15.572 96.43,15.473 96.447,15.346 C96.677,13.675 96.689,12.341 96.673,11.675 C96.669,11.53 96.786,11.411 96.934,11.411 Z M70.608,11.949 L71.697,11.949 C71.84,11.949 71.957,12.065 71.957,12.207 L71.957,37.449 C71.957,37.592 71.84,37.708 71.697,37.708 L65.672,37.708 C65.559,37.708 65.457,37.633 65.424,37.525 L65.09,36.435 C65.038,36.268 65.164,36.099 65.339,36.099 L70.087,36.099 C70.231,36.099 70.347,35.982 70.347,35.838 L70.347,12.207 C70.347,12.065 70.463,11.949 70.608,11.949 Z M118.948,11.277 L120.038,11.277 C120.182,11.277 120.298,11.395 120.298,11.537 L120.298,17.727 C120.298,17.87 120.414,17.988 120.558,17.988 L124.063,17.988 C124.205,17.988 124.322,18.104 124.322,18.246 L124.322,19.336 C124.322,19.481 124.205,19.596 124.063,19.596 L120.558,19.596 C120.414,19.596 120.298,19.713 120.298,19.858 L120.298,23.762 C120.298,23.907 120.414,24.024 120.558,24.024 L121.787,24.024 C121.899,24.024 121.997,24.093 122.033,24.198 L123.447,28.24 C123.506,28.409 123.38,28.585 123.202,28.585 L122.047,28.585 C121.937,28.585 121.838,28.514 121.802,28.41 L120.804,25.557 C120.706,25.281 120.298,25.351 120.298,25.644 L120.298,37.452 C120.298,37.596 120.182,37.712 120.038,37.712 L118.948,37.712 C118.805,37.712 118.688,37.596 118.688,37.452 L118.688,19.858 C118.688,19.713 118.57,19.596 118.428,19.596 L114.851,19.596 C114.706,19.596 114.59,19.481 114.59,19.336 L114.59,18.246 C114.59,18.104 114.706,17.988 114.851,17.988 L118.428,17.988 C118.57,17.988 118.688,17.87 118.688,17.727 L118.688,11.537 C118.688,11.395 118.805,11.277 118.948,11.277 Z" id="path-1"></path>
        <path d="M18.711,9.071 C19.106,10.111 20.102,11.444 22.769,13.171 L23.068,11.827 C23.068,11.827 21.011,10.363 19.935,9.48 C19.669,9.263 19.436,9.009 19.212,8.749 C19.036,8.544 18.881,8.447 18.774,8.447 C18.611,8.447 18.559,8.671 18.711,9.071 Z" id="path-3"></path>
        <path d="M20.313,2.529 C20.703,3.198 21.096,3.936 21.29,4.477 C23.194,8.311 23.084,13.771 20.707,18.114 C19.094,21.059 16.699,22.992 14.136,23.417 C13.487,23.524 11.778,23.549 10.412,23.063 C8.977,22.55 7.894,21.522 7.627,21.496 C6.994,21.438 7.718,22.547 7.862,22.681 C9.374,24.074 11.2,24.807 13.105,24.807 C13.516,24.807 13.93,24.773 14.345,24.704 C17.303,24.214 20.033,22.042 21.839,18.744 C24.745,13.437 24.509,6.546 21.523,2.335 C21.426,2.198 21.244,2.04 21.022,1.88 C20.93,1.812 20.831,1.783 20.737,1.783 C20.395,1.783 20.104,2.169 20.313,2.529 Z" id="path-5"></path>
        <path d="M20.313,2.529 C20.703,3.198 21.096,3.936 21.29,4.477 C23.194,8.311 23.084,13.771 20.707,18.114 C19.094,21.059 16.699,22.992 14.136,23.417 C13.487,23.524 11.778,23.549 10.412,23.063 C8.977,22.55 7.894,21.522 7.627,21.496 C6.994,21.438 7.718,22.547 7.862,22.681 C9.374,24.074 11.2,24.807 13.105,24.807 C13.516,24.807 13.93,24.773 14.345,24.704 C17.303,24.214 20.033,22.042 21.839,18.744 C24.745,13.437 24.509,6.546 21.523,2.335 C21.426,2.198 21.244,2.04 21.022,1.88 C20.929,1.812 20.831,1.783 20.737,1.783 C20.395,1.783 20.104,2.169 20.313,2.529 Z" id="path-7"></path>
    </defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Group-2">
            <mask id="mask-2" fill="white">
                <use xlink:href="#path-1"></use>
            </mask>
            <use id="Combined-Shape" fill="#000000" xlink:href="#path-1"></use>
            <g id="Group">
                <g id="Group-33" fill="#FF7055" fill-rule="nonzero">
                    <g id="Group-30">
                        <g id="Fill-28-Clipped">
                            <path d="M25.6312,0.4948 C11.4762,0.4948 0.0002,11.9708 0.0002,26.1258 C0.0002,40.2818 11.4762,51.7578 25.6312,51.7578 C39.7862,51.7578 51.2622,40.2818 51.2622,26.1258 C51.2622,11.9708 39.7862,0.4948 25.6312,0.4948" id="Fill-28"></path>
                        </g>
                    </g>
                </g>
                <g id="Group-79" transform="translate(9.000000, 8.000000)">
                    <path d="M6.9651,20.0329 C5.6871,19.6579 4.9661,18.2619 4.9661,18.2619 C4.9661,18.2619 6.3181,17.4729 7.5951,17.8479 C8.8731,18.2219 9.5941,19.6189 9.5941,19.6189 C9.5941,19.6189 8.2421,20.4069 6.9651,20.0329" id="Fill-61" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M3.5228,24.4753 C1.6958,24.6443 0.0788,23.2193 0.0788,23.2193 C0.0788,23.2193 1.4238,21.5223 3.2518,21.3543 C5.0798,21.1863 6.6968,22.6103 6.6968,22.6103 C6.6968,22.6103 5.3508,24.3073 3.5228,24.4753" id="Fill-63" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M10.9163,16.5945 C10.8953,15.0275 12.1953,13.7405 12.1953,13.7405 C12.1953,13.7405 13.5293,14.9935 13.5503,16.5595 C13.5703,18.1265 12.2703,19.4135 12.2703,19.4135 C12.2703,19.4135 10.9373,18.1605 10.9163,16.5945" id="Fill-65" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M28.6907,2.739 C30.4657,1.844 32.6517,2.628 32.6517,2.628 C32.6517,2.628 31.9587,4.859 30.1827,5.754 C28.4067,6.647 26.2207,5.864 26.2207,5.864 C26.2207,5.864 26.9157,3.633 28.6907,2.739" id="Fill-67" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M26.9378,11.6433 C28.5038,11.3053 30.0558,12.3623 30.0558,12.3623 C30.0558,12.3623 29.0678,13.9643 27.5008,14.3023 C25.9338,14.6393 24.3818,13.5823 24.3818,13.5823 C24.3818,13.5823 25.3708,11.9803 26.9378,11.6433" id="Fill-69" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M23.928,2.3777 C23.848,1.1497 24.808,0.0887 24.808,0.0887 C24.808,0.0887 25.898,1.0167 25.977,2.2437 C26.057,3.4707 25.096,4.5327 25.096,4.5327 C25.096,4.5327 24.007,3.6057 23.928,2.3777" id="Fill-71" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M16.0335,10.9714 C14.6945,10.9914 13.5925,9.8714 13.5925,9.8714 C13.5925,9.8714 14.6625,8.7184 16.0015,8.6984 C17.3405,8.6774 18.4415,9.7974 18.4415,9.7974 C18.4415,9.7974 17.3725,10.9504 16.0335,10.9714" id="Fill-73" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M18.848,3.9167 C20.302,5.2777 20.343,7.6157 20.343,7.6157 C20.343,7.6157 18.027,7.7457 16.573,6.3847 C15.119,5.0217 15.078,2.6847 15.078,2.6847 C15.078,2.6847 17.395,2.5547 18.848,3.9167" id="Fill-75" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M17.4056,26.1599 C17.0536,26.1219 16.7946,25.7549 16.8266,25.3379 C16.8586,24.9209 17.1696,24.6139 17.5216,24.6509 C17.8736,24.6899 18.1336,25.0569 18.1006,25.4739 C18.0696,25.8909 17.7586,26.1979 17.4056,26.1599 M26.9366,18.5649 C25.4776,18.9089 23.4266,20.1609 21.3996,21.1429 C15.9116,23.7999 9.1106,28.5629 8.4266,29.0139 C8.0876,29.2369 8.0266,29.7119 8.3016,30.0129 C8.5896,30.3269 8.6716,30.4609 9.3636,31.2509 C10.4076,32.3519 11.1966,32.6629 12.5836,32.4949 C14.2286,32.2429 15.9756,31.2309 17.0856,31.3559 C17.0856,31.3559 20.3476,31.5449 21.0206,30.4569 C21.0206,30.4569 24.1586,33.1929 24.0586,39.1099 C24.0536,39.3799 24.0376,39.8499 24.0186,40.1339 C24.0746,37.1389 23.0896,33.3719 21.0286,31.0539 C20.6396,31.3379 19.4136,32.0339 17.1506,31.7389 C18.1166,37.1729 16.5736,42.1859 15.5676,43.7299 C15.6156,43.7319 15.6636,43.7319 15.7126,43.7339 C15.7416,43.7289 15.7686,43.7369 15.7986,43.7359 C16.0756,43.7449 16.3506,43.7569 16.6316,43.7569 C21.4036,43.7569 25.8676,42.4489 29.6936,40.1779 C29.7256,40.1569 29.7566,40.1359 29.7886,40.1159 C28.2326,33.0689 22.6596,23.6149 22.6596,23.6149 C27.7516,23.7409 26.9366,18.5649 26.9366,18.5649" id="Fill-77" fill="#FFFFFF" fill-rule="nonzero"></path>
                    <path d="M12.081,20.345 C13.342,21.638 15.197,22.638 17.096,22.638 C17.559,22.638 18.026,22.579 18.487,22.449 C18.806,22.359 19.881,21.518 19.719,21.198 C19.557,20.876 19.166,20.749 18.849,20.913 C16.837,21.947 14.165,20.883 12.505,20.042 C12.427,20.003 12.346,19.985 12.274,19.985 C12.048,19.985 11.892,20.151 12.081,20.345 Z" id="path-25" fill="#FFFFFF"></path>
                    <path d="M25.375,5.067 C24.811,5.919 23.959,7.365 22.961,8.068 L23.107,9.391 C24.429,8.533 25.288,6.684 25.779,5.271 C25.838,5.099 25.7,4.964 25.558,4.964 C25.49,4.964 25.422,4.995 25.375,5.067 Z" id="path-27"></path>
                    <path d="M25.375,5.067 C24.811,5.919 23.959,7.365 22.961,8.068 L23.107,9.391 C24.429,8.533 25.288,6.684 25.779,5.271 C25.838,5.099 25.699,4.964 25.558,4.964 C25.491,4.964 25.422,4.995 25.375,5.067 Z" id="path-29" fill="#FFFFFF"></path>
                    <path d="M18.711,9.071 C19.106,10.111 20.102,11.444 22.769,13.171 L23.068,11.827 C23.068,11.827 21.011,10.363 19.935,9.48 C19.669,9.263 19.436,9.009 19.212,8.749 C19.036,8.543 18.881,8.447 18.774,8.447 C18.611,8.447 18.559,8.671 18.711,9.071 Z" id="path-31" fill="#FFFFFF"></path>
                    <mask id="mask-4" fill="white">
                        <use xlink:href="#path-3"></use>
                    </mask>
                    <g id="path-33"></g>
                    <mask id="mask-6" fill="white">
                        <use xlink:href="#path-5"></use>
                    </mask>
                    <g id="path-23"></g>
                    <path d="M21.0218,1.8796 C20.5938,1.5676 20.0458,2.0686 20.3128,2.5286 C20.7028,3.1976 21.0958,3.9366 21.2898,4.4766 C23.1938,8.3116 23.0848,13.7716 20.7078,18.1136 C19.0938,21.0596 16.6998,22.9916 14.1358,23.4166 C13.4878,23.5246 11.7788,23.5496 10.4128,23.0636 C8.9778,22.5506 7.8938,21.5216 7.6258,21.4966 C6.9938,21.4386 7.7178,22.5466 7.8628,22.6806 C9.3738,24.0736 11.1998,24.8076 13.1048,24.8076 C13.5158,24.8076 13.9298,24.7736 14.3448,24.7036 C17.3018,24.2146 20.0338,22.0416 21.8388,18.7436 C24.7458,13.4376 24.5088,6.5456 21.5228,2.3346 C21.4258,2.1976 21.2438,2.0396 21.0218,1.8796" id="Fill-31" fill="#FFFFFF" fill-rule="nonzero" mask="url(#mask-6)"></path>
                    <mask id="mask-8" fill="white">
                        <use xlink:href="#path-7"></use>
                    </mask>
                    <g id="path-21"></g>
                </g>
            </g>
        </g>
    </g>
</svg>

            </a>

            <div class="metabar-inner">
              <div class='u-clearfix u-relative'>
                <div class="xzl-header-body">
                  <a href="/", class="xzl-logo-link">
                      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="142px" height="52px" viewBox="0 0 142 52" version="1.1" class="xzl-logo">
    <!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs>
        <path d="M63.853,17.315 L65.037,17.315 C65.222,17.315 65.347,17.505 65.276,17.676 L59.733,30.84 C59.692,30.938 59.597,30.999 59.493,30.999 L58.311,30.999 C58.126,30.999 58,30.811 58.071,30.639 L63.614,17.473 C63.654,17.378 63.75,17.315 63.853,17.315 Z M76.879,17.315 L78.072,17.315 C78.175,17.315 78.268,17.374 78.31,17.47 L84.519,31.44 C84.595,31.612 84.469,31.804 84.281,31.804 L83.088,31.804 C82.986,31.804 82.892,31.744 82.851,31.651 L76.642,17.68 C76.567,17.508 76.693,17.315 76.879,17.315 Z M116.445,21.341 L117.548,21.341 C117.708,21.341 117.83,21.482 117.804,21.64 L116.306,31.316 C116.287,31.443 116.177,31.536 116.051,31.536 L114.946,31.536 C114.788,31.536 114.666,31.395 114.69,31.236 L116.188,21.56 C116.208,21.433 116.317,21.341 116.445,21.341 Z M136.192,11.948 L137.386,11.948 C137.572,11.948 137.698,12.142 137.623,12.314 L135.265,17.622 C135.188,17.794 135.314,17.987 135.501,17.987 L139.625,17.987 C139.77,17.987 139.887,18.103 139.887,18.248 L139.887,19.337 C139.887,19.48 139.77,19.596 139.625,19.596 L125.583,19.596 C125.439,19.596 125.323,19.48 125.323,19.337 L125.323,18.248 C125.323,18.103 125.439,17.987 125.583,17.987 L128.527,17.987 C128.717,17.987 128.843,17.794 128.766,17.622 L126.533,12.598 C126.456,12.425 126.582,12.232 126.772,12.232 L127.963,12.232 C128.065,12.232 128.158,12.294 128.201,12.387 L130.621,17.832 C130.662,17.927 130.757,17.987 130.859,17.987 L133.17,17.987 C133.273,17.987 133.367,17.927 133.408,17.832 L135.954,12.102 C135.996,12.008 136.09,11.948 136.192,11.948 Z M126.658,26.037 L138.552,26.037 C138.696,26.037 138.811,26.154 138.811,26.297 L138.811,27.387 C138.811,27.531 138.696,27.648 138.552,27.648 L126.658,27.648 C126.513,27.648 126.397,27.531 126.397,27.387 L126.397,26.297 C126.397,26.154 126.513,26.037 126.658,26.037 Z M124.271,35.566 L140.94,35.566 C141.082,35.566 141.199,35.682 141.199,35.827 L141.199,36.917 C141.199,37.06 141.082,37.178 140.94,37.178 L124.271,37.178 C124.126,37.178 124.01,37.06 124.01,36.917 L124.01,35.827 C124.01,35.682 124.126,35.566 124.271,35.566 Z M96.934,11.411 L98.027,11.411 C98.167,11.411 98.283,11.522 98.286,11.662 C98.308,12.369 98.3,13.664 98.102,15.278 C98.082,15.432 98.203,15.572 98.358,15.572 L109.382,15.572 C109.525,15.572 109.642,15.689 109.642,15.831 L109.642,16.921 C109.642,17.066 109.525,17.182 109.382,17.182 L98.005,17.182 C97.881,17.182 97.776,17.267 97.75,17.386 C97.537,18.404 97.241,19.485 96.837,20.586 C96.776,20.757 96.898,20.938 97.079,20.938 L110.992,20.938 C111.136,20.938 111.252,21.054 111.252,21.199 L111.252,22.287 C111.252,22.431 111.136,22.548 110.992,22.548 L96.162,22.548 C96.066,22.548 95.977,22.603 95.933,22.691 C95.344,23.87 94.609,25.039 93.695,26.145 C93.555,26.316 93.67,26.574 93.893,26.574 L107.661,26.574 C107.805,26.574 107.92,26.69 107.92,26.832 L107.92,28.181 L107.921,28.182 L107.92,28.182 L107.919,28.182 L100.642,33.953 C100.477,34.085 100.527,34.347 100.731,34.408 L105.856,35.898 C105.966,35.93 106.042,36.033 106.042,36.148 L106.042,37.283 C106.042,37.456 105.875,37.581 105.71,37.533 L89.324,32.765 C89.213,32.734 89.138,32.632 89.138,32.518 L89.138,31.381 C89.138,31.207 89.304,31.083 89.471,31.132 L98.223,33.678 C98.304,33.702 98.391,33.684 98.456,33.632 L104.743,28.649 C104.936,28.495 104.827,28.182 104.581,28.182 L91.349,28.182 C91.204,28.182 91.087,28.067 91.087,27.922 L91.087,26.684 C91.087,26.613 91.118,26.545 91.168,26.497 C92.319,25.406 93.232,24.19 93.954,22.936 C94.054,22.763 93.925,22.548 93.727,22.548 L85.909,22.548 C85.766,22.548 85.649,22.431 85.649,22.287 L85.649,21.199 C85.649,21.054 85.766,20.938 85.909,20.938 L94.772,20.938 C94.876,20.938 94.974,20.873 95.014,20.776 C95.474,19.658 95.808,18.547 96.05,17.498 C96.089,17.336 95.963,17.182 95.795,17.182 L87.251,17.182 C87.107,17.182 86.99,17.066 86.99,16.921 L86.99,15.831 C86.99,15.689 87.107,15.572 87.251,15.572 L96.188,15.572 C96.318,15.572 96.43,15.473 96.447,15.346 C96.677,13.675 96.689,12.341 96.673,11.675 C96.669,11.53 96.786,11.411 96.934,11.411 Z M70.608,11.949 L71.697,11.949 C71.84,11.949 71.957,12.065 71.957,12.207 L71.957,37.449 C71.957,37.592 71.84,37.708 71.697,37.708 L65.672,37.708 C65.559,37.708 65.457,37.633 65.424,37.525 L65.09,36.435 C65.038,36.268 65.164,36.099 65.339,36.099 L70.087,36.099 C70.231,36.099 70.347,35.982 70.347,35.838 L70.347,12.207 C70.347,12.065 70.463,11.949 70.608,11.949 Z M118.948,11.277 L120.038,11.277 C120.182,11.277 120.298,11.395 120.298,11.537 L120.298,17.727 C120.298,17.87 120.414,17.988 120.558,17.988 L124.063,17.988 C124.205,17.988 124.322,18.104 124.322,18.246 L124.322,19.336 C124.322,19.481 124.205,19.596 124.063,19.596 L120.558,19.596 C120.414,19.596 120.298,19.713 120.298,19.858 L120.298,23.762 C120.298,23.907 120.414,24.024 120.558,24.024 L121.787,24.024 C121.899,24.024 121.997,24.093 122.033,24.198 L123.447,28.24 C123.506,28.409 123.38,28.585 123.202,28.585 L122.047,28.585 C121.937,28.585 121.838,28.514 121.802,28.41 L120.804,25.557 C120.706,25.281 120.298,25.351 120.298,25.644 L120.298,37.452 C120.298,37.596 120.182,37.712 120.038,37.712 L118.948,37.712 C118.805,37.712 118.688,37.596 118.688,37.452 L118.688,19.858 C118.688,19.713 118.57,19.596 118.428,19.596 L114.851,19.596 C114.706,19.596 114.59,19.481 114.59,19.336 L114.59,18.246 C114.59,18.104 114.706,17.988 114.851,17.988 L118.428,17.988 C118.57,17.988 118.688,17.87 118.688,17.727 L118.688,11.537 C118.688,11.395 118.805,11.277 118.948,11.277 Z" id="path-1"></path>
        <path d="M18.711,9.071 C19.106,10.111 20.102,11.444 22.769,13.171 L23.068,11.827 C23.068,11.827 21.011,10.363 19.935,9.48 C19.669,9.263 19.436,9.009 19.212,8.749 C19.036,8.544 18.881,8.447 18.774,8.447 C18.611,8.447 18.559,8.671 18.711,9.071 Z" id="path-3"></path>
        <path d="M20.313,2.529 C20.703,3.198 21.096,3.936 21.29,4.477 C23.194,8.311 23.084,13.771 20.707,18.114 C19.094,21.059 16.699,22.992 14.136,23.417 C13.487,23.524 11.778,23.549 10.412,23.063 C8.977,22.55 7.894,21.522 7.627,21.496 C6.994,21.438 7.718,22.547 7.862,22.681 C9.374,24.074 11.2,24.807 13.105,24.807 C13.516,24.807 13.93,24.773 14.345,24.704 C17.303,24.214 20.033,22.042 21.839,18.744 C24.745,13.437 24.509,6.546 21.523,2.335 C21.426,2.198 21.244,2.04 21.022,1.88 C20.93,1.812 20.831,1.783 20.737,1.783 C20.395,1.783 20.104,2.169 20.313,2.529 Z" id="path-5"></path>
        <path d="M20.313,2.529 C20.703,3.198 21.096,3.936 21.29,4.477 C23.194,8.311 23.084,13.771 20.707,18.114 C19.094,21.059 16.699,22.992 14.136,23.417 C13.487,23.524 11.778,23.549 10.412,23.063 C8.977,22.55 7.894,21.522 7.627,21.496 C6.994,21.438 7.718,22.547 7.862,22.681 C9.374,24.074 11.2,24.807 13.105,24.807 C13.516,24.807 13.93,24.773 14.345,24.704 C17.303,24.214 20.033,22.042 21.839,18.744 C24.745,13.437 24.509,6.546 21.523,2.335 C21.426,2.198 21.244,2.04 21.022,1.88 C20.929,1.812 20.831,1.783 20.737,1.783 C20.395,1.783 20.104,2.169 20.313,2.529 Z" id="path-7"></path>
    </defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Group-2">
            <mask id="mask-2" fill="white">
                <use xlink:href="#path-1"></use>
            </mask>
            <use id="Combined-Shape" fill="#000000" xlink:href="#path-1"></use>
            <g id="Group">
                <g id="Group-33" fill="#FF7055" fill-rule="nonzero">
                    <g id="Group-30">
                        <g id="Fill-28-Clipped">
                            <path d="M25.6312,0.4948 C11.4762,0.4948 0.0002,11.9708 0.0002,26.1258 C0.0002,40.2818 11.4762,51.7578 25.6312,51.7578 C39.7862,51.7578 51.2622,40.2818 51.2622,26.1258 C51.2622,11.9708 39.7862,0.4948 25.6312,0.4948" id="Fill-28"></path>
                        </g>
                    </g>
                </g>
                <g id="Group-79" transform="translate(9.000000, 8.000000)">
                    <path d="M6.9651,20.0329 C5.6871,19.6579 4.9661,18.2619 4.9661,18.2619 C4.9661,18.2619 6.3181,17.4729 7.5951,17.8479 C8.8731,18.2219 9.5941,19.6189 9.5941,19.6189 C9.5941,19.6189 8.2421,20.4069 6.9651,20.0329" id="Fill-61" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M3.5228,24.4753 C1.6958,24.6443 0.0788,23.2193 0.0788,23.2193 C0.0788,23.2193 1.4238,21.5223 3.2518,21.3543 C5.0798,21.1863 6.6968,22.6103 6.6968,22.6103 C6.6968,22.6103 5.3508,24.3073 3.5228,24.4753" id="Fill-63" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M10.9163,16.5945 C10.8953,15.0275 12.1953,13.7405 12.1953,13.7405 C12.1953,13.7405 13.5293,14.9935 13.5503,16.5595 C13.5703,18.1265 12.2703,19.4135 12.2703,19.4135 C12.2703,19.4135 10.9373,18.1605 10.9163,16.5945" id="Fill-65" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M28.6907,2.739 C30.4657,1.844 32.6517,2.628 32.6517,2.628 C32.6517,2.628 31.9587,4.859 30.1827,5.754 C28.4067,6.647 26.2207,5.864 26.2207,5.864 C26.2207,5.864 26.9157,3.633 28.6907,2.739" id="Fill-67" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M26.9378,11.6433 C28.5038,11.3053 30.0558,12.3623 30.0558,12.3623 C30.0558,12.3623 29.0678,13.9643 27.5008,14.3023 C25.9338,14.6393 24.3818,13.5823 24.3818,13.5823 C24.3818,13.5823 25.3708,11.9803 26.9378,11.6433" id="Fill-69" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M23.928,2.3777 C23.848,1.1497 24.808,0.0887 24.808,0.0887 C24.808,0.0887 25.898,1.0167 25.977,2.2437 C26.057,3.4707 25.096,4.5327 25.096,4.5327 C25.096,4.5327 24.007,3.6057 23.928,2.3777" id="Fill-71" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M16.0335,10.9714 C14.6945,10.9914 13.5925,9.8714 13.5925,9.8714 C13.5925,9.8714 14.6625,8.7184 16.0015,8.6984 C17.3405,8.6774 18.4415,9.7974 18.4415,9.7974 C18.4415,9.7974 17.3725,10.9504 16.0335,10.9714" id="Fill-73" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M18.848,3.9167 C20.302,5.2777 20.343,7.6157 20.343,7.6157 C20.343,7.6157 18.027,7.7457 16.573,6.3847 C15.119,5.0217 15.078,2.6847 15.078,2.6847 C15.078,2.6847 17.395,2.5547 18.848,3.9167" id="Fill-75" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"></path>
                    <path d="M17.4056,26.1599 C17.0536,26.1219 16.7946,25.7549 16.8266,25.3379 C16.8586,24.9209 17.1696,24.6139 17.5216,24.6509 C17.8736,24.6899 18.1336,25.0569 18.1006,25.4739 C18.0696,25.8909 17.7586,26.1979 17.4056,26.1599 M26.9366,18.5649 C25.4776,18.9089 23.4266,20.1609 21.3996,21.1429 C15.9116,23.7999 9.1106,28.5629 8.4266,29.0139 C8.0876,29.2369 8.0266,29.7119 8.3016,30.0129 C8.5896,30.3269 8.6716,30.4609 9.3636,31.2509 C10.4076,32.3519 11.1966,32.6629 12.5836,32.4949 C14.2286,32.2429 15.9756,31.2309 17.0856,31.3559 C17.0856,31.3559 20.3476,31.5449 21.0206,30.4569 C21.0206,30.4569 24.1586,33.1929 24.0586,39.1099 C24.0536,39.3799 24.0376,39.8499 24.0186,40.1339 C24.0746,37.1389 23.0896,33.3719 21.0286,31.0539 C20.6396,31.3379 19.4136,32.0339 17.1506,31.7389 C18.1166,37.1729 16.5736,42.1859 15.5676,43.7299 C15.6156,43.7319 15.6636,43.7319 15.7126,43.7339 C15.7416,43.7289 15.7686,43.7369 15.7986,43.7359 C16.0756,43.7449 16.3506,43.7569 16.6316,43.7569 C21.4036,43.7569 25.8676,42.4489 29.6936,40.1779 C29.7256,40.1569 29.7566,40.1359 29.7886,40.1159 C28.2326,33.0689 22.6596,23.6149 22.6596,23.6149 C27.7516,23.7409 26.9366,18.5649 26.9366,18.5649" id="Fill-77" fill="#FFFFFF" fill-rule="nonzero"></path>
                    <path d="M12.081,20.345 C13.342,21.638 15.197,22.638 17.096,22.638 C17.559,22.638 18.026,22.579 18.487,22.449 C18.806,22.359 19.881,21.518 19.719,21.198 C19.557,20.876 19.166,20.749 18.849,20.913 C16.837,21.947 14.165,20.883 12.505,20.042 C12.427,20.003 12.346,19.985 12.274,19.985 C12.048,19.985 11.892,20.151 12.081,20.345 Z" id="path-25" fill="#FFFFFF"></path>
                    <path d="M25.375,5.067 C24.811,5.919 23.959,7.365 22.961,8.068 L23.107,9.391 C24.429,8.533 25.288,6.684 25.779,5.271 C25.838,5.099 25.7,4.964 25.558,4.964 C25.49,4.964 25.422,4.995 25.375,5.067 Z" id="path-27"></path>
                    <path d="M25.375,5.067 C24.811,5.919 23.959,7.365 22.961,8.068 L23.107,9.391 C24.429,8.533 25.288,6.684 25.779,5.271 C25.838,5.099 25.699,4.964 25.558,4.964 C25.491,4.964 25.422,4.995 25.375,5.067 Z" id="path-29" fill="#FFFFFF"></path>
                    <path d="M18.711,9.071 C19.106,10.111 20.102,11.444 22.769,13.171 L23.068,11.827 C23.068,11.827 21.011,10.363 19.935,9.48 C19.669,9.263 19.436,9.009 19.212,8.749 C19.036,8.543 18.881,8.447 18.774,8.447 C18.611,8.447 18.559,8.671 18.711,9.071 Z" id="path-31" fill="#FFFFFF"></path>
                    <mask id="mask-4" fill="white">
                        <use xlink:href="#path-3"></use>
                    </mask>
                    <g id="path-33"></g>
                    <mask id="mask-6" fill="white">
                        <use xlink:href="#path-5"></use>
                    </mask>
                    <g id="path-23"></g>
                    <path d="M21.0218,1.8796 C20.5938,1.5676 20.0458,2.0686 20.3128,2.5286 C20.7028,3.1976 21.0958,3.9366 21.2898,4.4766 C23.1938,8.3116 23.0848,13.7716 20.7078,18.1136 C19.0938,21.0596 16.6998,22.9916 14.1358,23.4166 C13.4878,23.5246 11.7788,23.5496 10.4128,23.0636 C8.9778,22.5506 7.8938,21.5216 7.6258,21.4966 C6.9938,21.4386 7.7178,22.5466 7.8628,22.6806 C9.3738,24.0736 11.1998,24.8076 13.1048,24.8076 C13.5158,24.8076 13.9298,24.7736 14.3448,24.7036 C17.3018,24.2146 20.0338,22.0416 21.8388,18.7436 C24.7458,13.4376 24.5088,6.5456 21.5228,2.3346 C21.4258,2.1976 21.2438,2.0396 21.0218,1.8796" id="Fill-31" fill="#FFFFFF" fill-rule="nonzero" mask="url(#mask-6)"></path>
                    <mask id="mask-8" fill="white">
                        <use xlink:href="#path-7"></use>
                    </mask>
                    <g id="path-21"></g>
                </g>
            </g>
        </g>
    </g>
</svg>

                  </a>
                  <div class="xzl-nav-header-center">
  <div class="metabar-block metabar-center xzl-pull-left xzl-nav-header">
    <div class="xzl-button-set ">
      <div class="xzl-header-link zhuanlan-topic-header">
        <a href="/cheaptalks">
        <img class="xzl-header-zhuanlan-logo" src="https://diycode.b0.upaiyun.com/photo/2017/a8e511e6d45335f875a7f710b34ae9c9.jpg" alt="A8e511e6d45335f875a7f710b34ae9c9" />
</a>        <span class='xzl-zhuanlan-name'>
          <a href="/cheaptalks">从源码角度看 Android</a></span>
        <button class="button button--small has-subscribed-btn xzl-btn-with-chrome xzl-base-color-normal-btn">
          <span class="button-label  xzl-default-state-btn">
            已经订阅
          </span>
        </button>
      </div>
    </div>
  </div>
</div>
<div class="metabar-block u-float-right  zhualan-header-btn xzl-header-right xzl-nav-header ">
  <div class="xzl-button-set">
    <button class="button link-btn apply-zhuanlan-btn xzl-btn-with-chrome xzl-base-color-normal-btn" data-link-url="/publication/new">
      <span class="button-label  xzl-default-state-btn">
        申请专栏
      </span>
    </button>
    <a class="button  topic-write-btn xzl-btn-with-chrome xzl-red-color-normal-btn" data-turbolinks='false' href="/topic/new">
      <span class="button-label  xzl-default-state-btn">
        写文章
      </span>
    </a>
    <div class="xzl-search-div  "
      title="搜索 文章、用户">
      <input class="js-predictiveSearchInput xzl-search-input textInput hidden  textInput--darkText u-baseColor--textNormal textInput--transparent"
        type="search" placeholder="搜索 文章、用户" value="" data-search-type=" "
        onkeydown="return checkKeyForSearchInput(event)">
      <span class="xzl-search-btn">
        <svg class="svgIcon-use" width="25" height="25" viewBox="0 0 25 25">
  <path d="M20.067 18.933l-4.157-4.157a6 6 0 1 0-.884.884l4.157 4.157a.624.624 0 1 0 .884-.884zM6.5 11c0-2.62 2.13-4.75 4.75-4.75S16 8.38 16 11s-2.13 4.75-4.75 4.75S6.5 13.62 6.5 11z">
  </path>
</svg>

      </span>
    </div>
    <button class="button xzl-primary-btn  xzl-notify-btn button--circle xzl-button-chrome-less is-touchIconBlackPulse is-inSiteNavBar  button--withIcon button--withSvgIcon button--activity js-notificationsButton link-btn is-counter"
      data-link-url="/notifications">
      <svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.666668 21.333332" height="21.333332" width="18.666668" xml:space="preserve" id="svg2" version="1.1" class="notice-icon"><metadata id="metadata8"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"></dc:type></cc:Work></rdf:RDF></metadata><defs id="defs6"><clipPath id="clipPath20" clipPathUnits="userSpaceOnUse"><path style="clip-rule:evenodd" id="path18" d="M 79.9531,149.012 C 102.797,144.414 120,124.289 120,99.9766 v -20.336 c 0.684,-1.1093 1.203,-2.2695 1.535,-3.4883 C 128.891,49.418 140,30 140,30 H 0 c 0,0 18.4648,19.3594 18.4648,46.1523 0,2.0118 0.5352,3.8672 1.5352,5.5743 v 18.25 C 20,124.191 37.2383,144.383 60.0469,149.008 60.0156,149.332 60,149.664 60,150 c 0,5.523 4.4766,10 10,10 5.5234,0 10,-4.477 10,-10 0,-0.332 -0.0156,-0.66 -0.0469,-0.988 z"></path></clipPath><clipPath id="clipPath26" clipPathUnits="userSpaceOnUse"><path id="path24" d="M 0,0 H 140 V 160 H 0 Z"></path></clipPath><clipPath id="clipPath36" clipPathUnits="userSpaceOnUse"><path style="clip-rule:evenodd" id="path34" d="M 50,20 C 50,8.95313 58.9531,0 70,0 v 0 c 11.0469,0 20,8.95313 20,20"></path></clipPath><clipPath id="clipPath42" clipPathUnits="userSpaceOnUse"><path id="path40" d="M 0,0 H 140 V 160 H 0 Z"></path></clipPath></defs><g transform="matrix(1.3333333,0,0,-1.3333333,0,21.333333)" id="g10"><g transform="scale(0.1)" id="g12"><g id="g14"><g clip-path="url(#clipPath20)" id="g16"><g clip-path="url(#clipPath26)" id="g22"><path id="path28" style="fill:none;stroke:#2b2b2c;stroke-width:20;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10;stroke-dasharray:none;stroke-opacity:1" d="M 79.9531,149.012 C 102.797,144.414 120,124.289 120,99.9766 v -20.336 c 0.684,-1.1093 1.203,-2.2695 1.535,-3.4883 C 128.891,49.418 140,30 140,30 H 0 c 0,0 18.4648,19.3594 18.4648,46.1523 0,2.0118 0.5352,3.8672 1.5352,5.5743 v 18.25 C 20,124.191 37.2383,144.383 60.0469,149.008 60.0156,149.332 60,149.664 60,150 c 0,5.523 4.4766,10 10,10 5.5234,0 10,-4.477 10,-10 0,-0.332 -0.0156,-0.66 -0.0469,-0.988 z"></path></g></g></g><g id="g30"><g clip-path="url(#clipPath36)" id="g32"><g clip-path="url(#clipPath42)" id="g38"><path id="path44" style="fill:none;stroke:#2b2b2c;stroke-width:20;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10;stroke-dasharray:none;stroke-opacity:1" d="M 50,20 C 50,8.95313 58.9531,0 70,0 v 0 c 11.0469,0 20,8.95313 20,20"></path></g></g></g></g></g></svg>

      <span class="notifications-count notifications-count-1">
        2</span>
    </button>
    <div class="nav-user-btn">
      <div class="xzl-popover js-popover popover--menu popover--userActions u-resetSpectrum popover--bottom">
  <div class="popover-inner js-popover-inner">
    <ul role="menu" class="list list--borderless list--short list--large">
      <li class="list-item  profile-list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark"
        href="/u/2300833237">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="19px" viewBox="0 0 16 19" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_home</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -272.000000)" id="icon_title_home">
            <g transform="translate(101.000000, 271.000000)">
                <rect id="Rectangle-6" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"></rect>
                <path d="M2.5,7.05988314 L2.5,18.5481306 L17.5,18.5481306 L17.5,7.05792375 L10.0504226,1.61772806 L2.5,7.05988314 Z" id="Rectangle-5" stroke="#818181"></path>
            </g>
        </g>
    </g>
</svg>
</div>
          <span>我的主页</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark"
        href="/me/publications">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="20px" viewBox="0 0 16 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_write</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -309.000000)" id="icon_title_write">
            <g transform="translate(101.000000, 309.000000)">
                <rect id="Rectangle-6-Copy-3" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"></rect>
                <g id="Group-11" transform="translate(3.000000, 1.000000)">
                    <path d="M12.0961903,0.007217431 C12.0950805,0.0840940228 12.0950805,0.0840940228 12.0906395,0.395412629 C12.0850882,0.787332723 12.0850882,0.787332723 12.0784271,1.26720127 C12.0777553,1.31600737 12.0777553,1.31600737 12.0770847,1.36488756 C12.0668478,2.11165141 12.0607067,2.60264713 12.0607067,2.69788938 C12.0607067,6.32194788 12.289768,6.9994991 14.1388632,7.82437955 L14.7391139,8.09215109 L14.3208675,8.59917427 C14.2665361,8.66503806 14.1640261,8.79017314 14.0202307,8.96709441 C13.7802215,9.26239406 13.5126946,9.59453175 13.224549,9.95601411 C12.4013961,10.9886699 11.5783121,12.0490614 10.810665,13.0769552 C10.5999821,13.3590636 10.3960273,13.6353691 10.199511,13.905095 C8.79888518,15.8275065 7.84211607,17.324416 7.50283568,18.1836368 L6.99871818,19.4603042 L6.56357072,18.1585128 C6.31659787,17.4196664 5.27609449,15.8389268 3.69252103,13.7328647 C3.51910808,13.5022353 3.340172,13.2666053 3.1561826,13.026487 C2.38210362,12.0162628 1.55216778,10.9696955 0.722164795,9.94741462 C0.431620618,9.58956318 0.161861606,9.26035845 -0.0801598352,8.96734649 C-0.225186026,8.79176531 -0.32859731,8.66743427 -0.383446471,8.60189193 L-0.81077199,8.09125674 L-0.201226262,7.82328398 C1.66784689,7.00158895 1.88639943,6.41530449 1.87559852,3.22164643 C1.87474274,2.96591436 1.87445639,2.84929113 1.87445639,2.69788938 C1.87445639,2.01038775 1.85698975,0.201713964 1.8415311,0.0510256659 L1.78500307,-0.5 L12.1035127,-0.5 L12.0961903,0.007217431 Z" id="Combined-Shape" stroke="#818181" stroke-linejoin="round"></path>
                    <rect id="Rectangle-23" fill="#818181" x="6.5" y="8" width="1" height="10"></rect>
                    <circle id="Oval-7" fill="#818181" cx="7" cy="8" r="1"></circle>
                </g>
            </g>
        </g>
    </g>
</svg>
</div>
          <span>我的专栏</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark"
        href="/me/subscribes">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="18px" viewBox="0 0 16 18" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_booking</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -348.000000)" id="icon_title_booking">
            <g transform="translate(101.000000, 347.000000)">
                <rect id="Rectangle-6-Copy-4" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"></rect>
                <g id="Group-10" transform="translate(2.000000, 1.000000)" stroke="#818181">
                    <rect id="Rectangle-24" x="0.5" y="0.5" width="15" height="17" rx="2"></rect>
                    <path d="M8.5,0.5 L8.5,7.32310369 L11,6.55419486 L13.5,7.32310369 L13.5,0.5 L8.5,0.5 Z" id="icon_mark-copy"></path>
                </g>
            </g>
        </g>
    </g>
</svg>
</div>
          <span>我的订阅</span>
        </a>
      </li>
      <li class="list-item list-item--separator list-item--separator-zero">
      </li>
      <li class="list-item topic-list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark"
        href="/me/topics" tabindex="-1" role="menuitem">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14px" height="16px" viewBox="0 0 14 16" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_word</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-155.000000, -273.000000)" id="icon_title_word">
            <g transform="translate(152.000000, 271.000000)">
                <rect id="Rectangle-6-Copy-5" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"></rect>
                <g id="Group-9" transform="translate(3.000000, 2.000000)">
                    <path d="M0.5,0.5 L0.5,15.5 L13.5,15.5 L13.5,3.25704929 L10.8221801,0.5 L0.5,0.5 Z" id="Rectangle-21" stroke="#818181"></path>
                    <rect id="Rectangle-22" fill="#818181" x="3" y="4" width="4" height="1"></rect>
                    <rect id="Rectangle-22-Copy" fill="#818181" x="3" y="7" width="8" height="1"></rect>
                    <rect id="Rectangle-22-Copy-2" fill="#818181" x="3" y="10" width="8" height="1"></rect>
                </g>
            </g>
        </g>
    </g>
</svg>
</div>
          <span>我的文章</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark"
        href="/me/drafts" tabindex="-1" role="menuitem">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="15px" viewBox="0 0 16 15" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_draft</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-154.000000, -312.000000)" id="icon_title_draft">
            <g transform="translate(152.000000, 309.000000)">
                <rect id="Path" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"></rect>
                <path d="M2.5,10.6911545 L2.5,15.5863661 C2.5,16.4258256 3.16515947,17.0922852 3.99406028,17.0922852 L16.0059397,17.0922852 C16.8293478,17.0922852 17.5,16.4180516 17.5,15.5863661 L17.5,10.6857048 L14.7177287,3.5 L5.45966255,3.5 L2.5,10.6911545 Z" id="Rectangle-40" stroke="#818181"></path>
                <path d="M14,11 L14,12.334029 C14,12.7018346 13.6354685,13 13.2036819,13 L6.79631805,13 C6.35652374,13 6,12.7048931 6,12.334029 L6,11" id="Rectangle-41" stroke="#818181"></path>
                <rect id="Rectangle-20" fill="#818181" x="2" y="11" width="4" height="1"></rect>
                <rect id="Rectangle-20-Copy" fill="#818181" x="14" y="11" width="4" height="1"></rect>
            </g>
        </g>
    </g>
</svg>
</div>
          <span>我的草稿</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark"
        href="/me/collections" tabindex="-1" role="menuitem">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14px" height="18px" viewBox="0 0 14 18" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_mark</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-155.000000, -348.000000)" id="icon_title_mark">
            <g transform="translate(152.000000, 347.000000)">
                <rect id="Rectangle-6-Copy" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"></rect>
                <path d="M3.5,18.330184 L10,16.4024198 L16.5,18.330184 L16.5,2.99508929 C16.5,2.16960364 15.8266399,1.5 14.9941413,1.5 L5.00585866,1.5 C4.1729829,1.5 3.5,2.16959875 3.5,2.99508929 L3.5,18.330184 Z" id="icon_mark" stroke="#818181"></path>
            </g>
        </g>
    </g>
</svg>
</div>
          <span>我的收藏</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark"
        href="/wallet" tabindex="-1" role="menuitem">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="15px" viewBox="0 0 16 15" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_wallet</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-205.000000, -274.000000)" id="icon_title_wallet">
            <g transform="translate(203.000000, 271.000000)">
                <rect id="Rectangle-6-Copy-2" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"></rect>
                <g id="Group-14" transform="translate(2.000000, 3.000000)">
                    <path d="M15.5,14.5 L15.5,0.5 L1.99406028,0.5 C1.16986472,0.5 0.5,1.16873005 0.5,1.99188419 L0.5,13.0081158 C0.5,13.8309529 1.16940651,14.5 1.99406028,14.5 L15.5,14.5 Z" id="Rectangle-15" stroke="#818181"></path>
                    <path d="M15.5,3.5 L15.5,0.5 L1.99406028,0.5 C1.17032001,0.5 0.5,1.17191112 0.5,2 C0.5,2.83350313 1.16628956,3.5 1.99406028,3.5 L15.5,3.5 Z" id="Rectangle-15-Copy" stroke="#818181"></path>
                    <path d="M15.5,10.5 L15.5,7.5 L11.0059191,7.5 C10.1667923,7.5 9.5,8.16747386 9.5,9 C9.5,9.83283752 10.1709214,10.5 11.0059191,10.5 L15.5,10.5 Z" id="Rectangle-15-Copy-2" stroke="#818181"></path>
                    <rect id="Rectangle-16" fill="#FFFFFF" x="15" y="1" width="1" height="2"></rect>
                </g>
            </g>
        </g>
    </g>
</svg>
</div>
          <span>我的钱包</span>
        </a>
      </li>
      <li class="list-item list-item--separator list-item--separator-part-one">
      </li>
      <li class="list-item setting-list-item u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark"
        href="/me/settings" tabindex="-1" role="menuitem">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="19px" viewBox="0 0 16 19" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_setting</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-205.000000, -309.000000)" id="icon_title_setting">
            <g transform="translate(203.000000, 309.000000)">
                <rect id="Rectangle-6-Copy-7" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"></rect>
                <g id="Group-15" transform="translate(2.000000, 0.000000)" stroke="#818181">
                    <path d="M7.86121593,1.42264973 L0.5,5.67264973 L0.5,14.1726497 L7.86121593,18.4226497 L15.2224319,14.1726497 L15.2224319,5.67264973 L7.86121593,1.42264973 Z" id="Polygon"></path>
                    <circle id="Oval-14" cx="8" cy="10" r="2.5"></circle>
                </g>
            </g>
        </g>
    </g>
</svg>
</div>
          <span>设置</span>
        </a>
      </li>

      <li class="list-item u-padding0">
        <a href="/account/sign_out" class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" data-method="delete">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="15px" viewBox="0 0 18 15" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_quit</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-205.000000, -350.000000)" id="icon_title_quit">
            <g transform="translate(203.000000, 347.000000)">
                <rect id="Rectangle-6-Copy-2" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"></rect>
                <g id="Group-16" transform="translate(2.000000, 3.000000)" stroke="#818181">
                    <polyline id="Rectangle-19" transform="translate(12.000000, 7.535534) rotate(-45.000000) translate(-12.000000, -7.535534) " points="15.2071068 4.32842712 15.2071068 10.7426407 8.79289322 10.7426407"></polyline>
                    <rect id="Rectangle-18" x="5.5" y="7.5" width="10" height="1"></rect>
                    <path d="M8.5,14.5 L8.5,0.5 L0.5,0.5 L0.5,14.5 L8.5,14.5 Z" id="Rectangle-39"></path>
                </g>
            </g>
        </g>
    </g>
</svg>
</div>
          <span>退出</span>
        </a>
      </li>
    </ul>
  </div>
  <div class="popover-arrow">
  </div>
</div>

<script type="text/javascript">
  $(".nav-user-btn").click(function(e){
    $(".xzl-invite-card").hide()
    if($(".popover--userActions").hasClass("is-active")){
      //$(this).css("background-color","rgba(255,255,255,0)")
      $(".popover--userActions").removeClass("is-active")
    }else{
      //$(this).css("background-color","rgba(245,245,245,1)")
      $(".popover--userActions").addClass("is-active")
      $(".popover--userActions").show()
    }
    e.stopPropagation()
  })

  $(".xzl-popover").off("click").click(function(e){
    e.stopPropagation()
  })
  $(window).click(function(e) {
    $(".xzl-popover").hide()
    //$(".nav-user-btn").css("background-color","rgba(255,255,255,0)")
    $(".popover--userActions").removeClass("is-active")
    if($(".is-search").length == 0){
      $(".xzl-search-div").removeClass("is-active")
      $(".xzl-search-input").addClass("hidden")
    }
  });
</script>
      <img class="cirle-user-avatar-36" src="https://diycode.b0.upaiyun.com/photo/2018/8d63845d9d9fd12b9f298314160110e7." alt="8d63845d9d9fd12b9f298314160110e7" />
    </div>
    <div class='nav-menu-btn'>
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="60px" height="60px" viewBox="0 0 60 60" version="1.1" class="nav-menu-btn-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 2</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-22.000000, -146.000000)" fill="#2D2E2F" fill-rule="nonzero">
            <g id="Group-2" transform="translate(22.000000, 146.000000)">
                <g id="Group" transform="translate(9.000000, 12.000000)">
                    <rect id="Rectangle" x="0" y="0" width="42" height="5"></rect>
                    <rect id="Rectangle-Copy" x="0" y="16" width="42" height="5"></rect>
                    <rect id="Rectangle-Copy-2" x="0" y="32" width="42" height="5"></rect>
                </g>
            </g>
        </g>
    </g>
</svg>

    </div>
    <div class='nav-menu-btn nav-menu-btn-hide'>
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="60px" height="60px" viewBox="0 0 60 60" version="1.1" class="nav-menu-btn-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 3</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-128.000000, -146.000000)" fill="#2D2E2F" fill-rule="nonzero">
            <g id="Group-3" transform="translate(128.000000, 146.000000)">
                <g id="Group" transform="translate(13.000000, 13.000000)">
                    <rect id="Rectangle-Copy" transform="translate(17.000000, 17.500000) scale(-1, 1) rotate(45.000000) translate(-17.000000, -17.500000) " x="-4" y="15" width="42" height="5"></rect>
                    <rect id="Rectangle-Copy" transform="translate(17.000000, 17.500000) rotate(45.000000) translate(-17.000000, -17.500000) " x="-4" y="15" width="42" height="5"></rect>
                </g>
            </g>
        </g>
    </g>
</svg>

    </div>

  </div>
</div>
<script id="template" type="text/x-handlebars-template">
  <div class="menu-float">
    <div class="menu-float-box">
      <a href='/' class="menu-float-line">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="42px" height="42px" viewBox="0 0 42 42" version="1.1" class="menu-float-line-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 22</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-304.000000, -99.000000)">
            <g id="Group-22" transform="translate(304.000000, 99.000000)">
                <rect id="Rectangle-6" fill="#FF0000" opacity="0" x="0" y="0" width="42" height="42"></rect>
                <polygon id="Rectangle-5" fill="#2D2E2F" points="4.2 14.2882472 21.1099219 2.1 37.8 14.2882472 37.8 40.0010742 4.2 40.0010742"></polygon>
            </g>
        </g>
    </g>
</svg>

        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="42px" height="42px" viewBox="0 0 42 42" version="1.1" class="menu-float-line-icon_no">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 22 Copy</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-391.000000, -99.000000)">
            <g id="Group-22-Copy" transform="translate(391.000000, 99.000000)">
                <rect id="Rectangle-6" fill="#FF0000" opacity="0" x="0" y="0" width="42" height="42"></rect>
                <polygon id="Rectangle-5" fill="#A9A9A9" points="4.2 14.2882472 21.1099219 2.1 37.8 14.2882472 37.8 40.0010742 4.2 40.0010742"></polygon>
            </g>
        </g>
    </g>
</svg>

        <div class="menu-float-text">首页</div>
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="30px" viewBox="0 0 18 30" version="1.1" class="menu-float-line-right">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Shape</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-508.000000, -217.000000)" fill="#C7C7C7" fill-rule="nonzero">
            <polygon id="Shape" transform="translate(516.828427, 231.828427) scale(-1, 1) translate(-516.828427, -231.828427) " points="513.656854 231.828427 525.656854 243.828427 522.828427 246.656854 508 231.828427 522.828427 217 525.656854 219.828427"></polygon>
        </g>
    </g>
</svg>

      </a>
      <a href='/explore' class="menu-float-line">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" height="40px" viewBox="0 0 40 40" version="1.1" class="menu-float-line-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Combined Shape</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-305.000000, -210.000000)" fill="#2D2E2F" fill-rule="nonzero">
            <path d="M325,250 C313.954305,250 305,241.045695 305,230 C305,218.954305 313.954305,210 325,210 C336.045695,210 345,218.954305 345,230 C345,241.045695 336.045695,250 325,250 Z M321.815941,227.206595 L312.840919,242.244696 L327.87902,233.269674 L336.854042,218.231573 L321.815941,227.206595 Z M325,232 C323.895431,232 323,231.104569 323,230 C323,228.895431 323.895431,228 325,228 C326.104569,228 327,228.895431 327,230 C327,231.104569 326.104569,232 325,232 Z" id="Combined-Shape"></path>
        </g>
    </g>
</svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" height="40px" viewBox="0 0 40 40" version="1.1" class="menu-float-line-icon_no">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Combined Shape Copy</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-392.000000, -210.000000)" fill="#A9A9A9" fill-rule="nonzero">
            <path d="M412,250 C400.954305,250 392,241.045695 392,230 C392,218.954305 400.954305,210 412,210 C423.045695,210 432,218.954305 432,230 C432,241.045695 423.045695,250 412,250 Z M408.815941,227.206595 L399.840919,242.244696 L414.87902,233.269674 L423.854042,218.231573 L408.815941,227.206595 Z M412,232 C410.895431,232 410,231.104569 410,230 C410,228.895431 410.895431,228 412,228 C413.104569,228 414,228.895431 414,230 C414,231.104569 413.104569,232 412,232 Z" id="Combined-Shape-Copy"></path>
        </g>
    </g>
</svg>

          <div class="menu-float-text">发现</div>
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="30px" viewBox="0 0 18 30" version="1.1" class="menu-float-line-right">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Shape</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-508.000000, -217.000000)" fill="#C7C7C7" fill-rule="nonzero">
            <polygon id="Shape" transform="translate(516.828427, 231.828427) scale(-1, 1) translate(-516.828427, -231.828427) " points="513.656854 231.828427 525.656854 243.828427 522.828427 246.656854 508 231.828427 522.828427 217 525.656854 219.828427"></polygon>
        </g>
    </g>
</svg>

      </a>
      <a href='/book' class="menu-float-line">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="41px" height="37px" viewBox="0 0 41 37" version="1.1" class="menu-float-line-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 3</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-304.000000, -322.000000)" fill="#2D2E2F">
            <g id="Group-3" transform="translate(304.000000, 322.000000)">
                <rect id="Rectangle-2" x="0" y="32" width="39" height="5"></rect>
                <polygon id="Rectangle-4" points="2 4 10 4 10 28 2 28"></polygon>
                <polygon id="Rectangle-4-Copy" points="15 0 23 0 23 29 15 29"></polygon>
                <polygon id="Rectangle-4-Copy-2" transform="translate(32.000000, 15.500000) rotate(-23.000000) translate(-32.000000, -15.500000) " points="28.0524805 3 36 3 35.9475195 28 28 28"></polygon>
            </g>
        </g>
    </g>
</svg>

        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="41px" height="37px" viewBox="0 0 41 37" version="1.1" class="menu-float-line-icon_no">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 3 Copy</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-391.000000, -322.000000)" fill="#A9A9A9">
            <g id="Group-3-Copy" transform="translate(391.000000, 322.000000)">
                <rect id="Rectangle-2" x="0" y="32" width="39" height="5"></rect>
                <polygon id="Rectangle-4" points="2 4 10 4 10 28 2 28"></polygon>
                <polygon id="Rectangle-4-Copy" points="15 0 23 0 23 29 15 29"></polygon>
                <polygon id="Rectangle-4-Copy-2" transform="translate(32.000000, 15.500000) rotate(-23.000000) translate(-32.000000, -15.500000) " points="28.0524805 3 36 3 35.9475195 28 28 28"></polygon>
            </g>
        </g>
    </g>
</svg>

        <div class="menu-float-text">小书</div>
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="30px" viewBox="0 0 18 30" version="1.1" class="menu-float-line-right">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Shape</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-508.000000, -217.000000)" fill="#C7C7C7" fill-rule="nonzero">
            <polygon id="Shape" transform="translate(516.828427, 231.828427) scale(-1, 1) translate(-516.828427, -231.828427) " points="513.656854 231.828427 525.656854 243.828427 522.828427 246.656854 508 231.828427 522.828427 217 525.656854 219.828427"></polygon>
        </g>
    </g>
</svg>

      </a>
    </div>
    <div onclick="closeMenu()"  class="menu-float-bottom"></div>
  </div>
</script>
<script type="text/javascript">
  var menuState = false
  var nowHref =  window.location.href.split('//')[1].split('/')[1].split('?')[0]
  function openPhoneMenu() {
    $($('.nav-menu-btn')[0]).addClass('nav-menu-btn-hide')
    $($('.nav-menu-btn')[1]).removeClass('nav-menu-btn-hide')
    $('body').append($('#template').html())
    $('body').css('overflow', 'hidden')
    $('html').css('height', '100%')
    $('body').css('height', '100%')
    $('.menu-float').css('top', '48px')
    $('.menu-float').css('height', $('body').height() - 47)
    if(nowHref === ''){
      $($('.menu-float-line')[0]).addClass('menu-float-line-active')
    }
    else if(nowHref === 'explore'){
      $($('.menu-float-line')[1]).addClass('menu-float-line-active')
    }
    else if(nowHref === 'book'){
      $($('.menu-float-line')[2]).addClass('menu-float-line-active')
    }
  }
  function closeMenu(){
    $($('.nav-menu-btn')[1]).addClass('nav-menu-btn-hide')
    $($('.nav-menu-btn')[0]).removeClass('nav-menu-btn-hide')
    $('.menu-float').remove()
    $('body').css('overflow', 'auto')
    $('html').css('height', 'auto')
    $('body').css('height', 'auto')
  }
  $($('.nav-menu-btn')[1]).click(function(){
    closeMenu()
  })
  // $('.menu-float-bottom').on('click',function(){
  //   closeMenu()
  // })
  $($('.nav-menu-btn')[0]).click(function(){
    if (menuState) {
      
    }
    else{
      openPhoneMenu()
    }
  })
  function submitSearchQuery() {
    var key = $(".xzl-search-input").val()
    if (!key) {
      $(".xzl-search-div").removeClass("is-active")
      $(".xzl-search-input").addClass("hidden")
    } else {
      Turbolinks.visit("/search?q=" + key + "&type=" + $(".xzl-search-input").data("search-type"), { action: "replace" })
    }
  }
  $(".xzl-search-btn").unbind("click")
  $(".xzl-search-btn").click(function (e) {
    if ($(".xzl-search-div").hasClass("is-active")) {
      submitSearchQuery()
    } else {
      $(".xzl-search-div").addClass("is-active")
      $(".xzl-search-input").removeClass("hidden")
      $(".xzl-search-input").focus()
    }
    e.stopPropagation()
  })
  $(".xzl-search-div").unbind("click")
  $(".xzl-search-div").click(function (e) {
    e.stopPropagation()
  })

  function checkKeyForSearchInput(event) {
    console.log(event)
    if (event.keyCode == 13) {
      submitSearchQuery()
    }
  }
</script>
                </div>
              </div>
            </div>
          </div>
        </div>
      <style type="text/css">
  
</style>
<div class="main topic-show-partial-main container">
  <article class="topic-show-partial">
    <div class="xzl-topic-content">
      <section>
        <div class="section-content">
          <div class="section-inner xzl-home-containner xzl-topic-show-body">
            <div class="topic-title">
              从源码角度看Handler
            </div>
            <div class="topic-header">
              <div class="postMetaInline">
                <div class="xzl-flex-center">
                  <div class="post-meta-inline-avatar u-flex0">
                    <a class="link avatar xzl-link-color" href="/u/1253528474">
                      <img class="avatar-image" src="https://diycode.b0.upaiyun.com/photo/2017/0137eba3bc45d85d51dffc218dff50ed.jpeg" alt="0137eba3bc45d85d51dffc218dff50ed" />
                    </a>
                  </div>
                  <div class="xzl-author-lockup xzl-author-lockup-user u-flex1 u-noWrapWithEllipsis">
                    <div class="xzl-author-lockup-header">
                      <a class="link link link--darken user-name link--accent u-accentColor--textNormal xzl-text-darken xzl-link-color" href="/u/1253528474">
                        RickAi
                      </a>
                        <button class="button xzl-primary-btn link-btn    xzl-basic-btn xzl-btn-with-chrome  btn-follow-user "
                          data-user-id="15665"
                          data-followed="false" data-following-btn=true>
                            <span class="button-label  xzl-default-state-btn js-buttonLabel" >
                              + 关注
                            </span>
                        </button>
                    </div>
                    <div class="xzl-author-lockup xzl-author-lockup-time">
                      <span class="read_time">
                        预计阅读时间93分钟
                      </span>
                      <span class="time"><abbr class="timeago" title="2018-07-22T10:41:05+08:00"></abbr></span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
                <textarea class="hidden hidden_topic_body hidden_markdown_body" data-summary="## 简介

Handler这套线程异步通信框架在Android中的地位是不亚于Binder的，因为其基础设计简单、涉及的知识面广、业务使用场景多等原因，十分适合应用层的初中级的工程师进行深入学习

这篇文章中我将分析Handler核心功能的源码，分析将贯穿着framework, native和kernel的知识点：

1. Handler发送异步消息原理
2. Looper派发消息原理
3. 消息分割栏的原理与视图绘制的运用
4. epoll_create, epoll_ctl, epoll_wait三部曲的源码分析
5. epoll中生产者与消费者模型的运用

同时按惯例，会在开篇给出总括全局的类图与架构图，方面阅读中定位理解与阅读后的回顾

## 设计图

### 类图

![](https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_class_diagram.jpg)

* Message: 消息的抽象
* Handler: 发送消息的工具类clo
* MessageQueue: 主要维护了消息队列，同时也是与native通信的中枢
* Looper: 循环获取消息并进行派发
* Messenger: 可以跨进程传输的消息抽象

### 架构图

![](https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_arch.jpg)

1. 一个APP中运行着多个线程，不同线程间可以互相拿到对方的Handler对象
2. MessageQueue和native直接通信，native中又和kernel通信，这样的调用链赋予了APP使用系统内核资源的能力
3. epoll机制在kernel中维护了一个链表与一颗红黑树是它效率优于poll与select的基础

## 发送跨线程异步消息: Handler.post()

使用Handler的前提是获取到它的引用对象，然后才能够在对应的MessageQueue的消息队列插入消息。能够这样做的根本原因在于，线程之间的内存是可以相互访问的，这也是Handler能够实现跨线程通信的基本原理之一

下面从最常用的`Handler.post()`方法入手，看看消息发送的实现原理，这里需要说明的一点是，使用Handler发送消息的花样很多，但最终都需要调用到`MessageQueue.enqueueMessage()`方法来实现，这里就不一一介绍API的使用了

frameworks/base/core/java/android/os/Handler.java

```java
public final boolean post(Runnable r)
{
    return  sendMessageDelayed(getPostMessage(r), 0);
}

public final boolean postAtTime(Runnable r, long uptimeMillis)
{
    return sendMessageAtTime(getPostMessage(r), uptimeMillis);
}

public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    // 这里获取到队列，队列是该线程唯一的，在Handler初始化时获取
    MessageQueue queue = mQueue;
    ...
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    // 判断是否为异步消息，异步消息将不会受到分割栏的影响
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    // 最终调用到MessageQueue去插入消息
    return queue.enqueueMessage(msg, uptimeMillis);
}
```

可以看到Handler只是一个类似于工具的类，最终的消息管理方面的操作还是需要委托给MessageQueue去做

frameworks/base/core/java/android/os/MessageQueue.java

```java
boolean enqueueMessage(Message msg, long when) {
    // 这里会强制target成员的设置，分割栏的插入不是调用这个方法实现的
    if (msg.target == null) {
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);

        // 因为不同的线程都可以调用这个方法，所以使用类锁保证消息队列的异步安全
        synchronized (this) {
            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                // 遍历消息队列，插入到合适的位置
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // 调用到native尝试唤醒对端设备
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
}
```

frameworks/base/core/jni/android_os_MessageQueue.cpp

```cpp
static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {
	// 通过ptr获取到NativeMessageQueue对象
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;wake();
}

void NativeMessageQueue::wake() {
	// 委托给native层的Looper进行处理
    mLooper-&gt;wake();
}
```

system/core/libutils/Looper.cpp

```cpp
void Looper::wake() {
    uint64_t inc = 1;
    // 向文件描述符为mWakeEventFd设备写入，以此来唤醒监听设备的epoll
    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));
    ...
}
```

总结一下消息发送的主要工作：

1. 在java层的消息队列中根据时间插入消息
2. 在native层，向对应的fd设备写入数据，以此来唤醒监听该设备的epoll

## 处理消息: Handler.handleMessage()

handleMessage完全是处于被动调用的状态，每当消息到来时，会从kernel依次调用的native，再到java层的Looper

这里直接看Looper是如何获取到消息，并调用handleMessage的，省去了`Looper.prepare()`代码的分析

frameworks/base/core/java/android/os/Looper.java

```java
public static void loop() {
    // 从ThreadLocal中取出之前放入的Looper对象
    final Looper me = myLooper();
    // 获取到队列
    final MessageQueue queue = me.mQueue;

    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        // 获取下一个消息，这个方法在没有消息时会产生阻塞，只有在消息到来时才会触发
        Message msg = queue.next(); // might block
        
        ...

        // 派发消息，最终会调用到Handler.handleMessage方法
        try {
            msg.target.dispatchMessage(msg);
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        
        ...
        
        // 回收Message
        msg.recycleUnchecked();
    }
}
```

继续看看MessageQueue.next的实现：

frameworks/base/core/java/android/os/MessageQueue.java

```java
Message next() {
	// mPtr实际上是NativeMesssageQueue的引用，方便在native层查询到MessageQueue
    final long ptr = mPtr;

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        // 调用native方法，之后调用到epoll_wait
        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // 消息分割栏，后面会做分析
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                // 如果当前时间没有已经就绪的message，那么重置poll事件的时间
                if (now &lt; msg.when) {
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;

                    msg.markInUse();
                    // 如果该消息已经就绪，那么将它返回给Looper进行派发
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
        }

        // 如果此次没有处理消息，则用来处理IdleHandler的操作，把优先级不高的操作放到这里去执行，尽量不浪费事件片
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
    }
}
```

核心操作`nativePollOnce`同样是在native层进行处理

frameworks/base/core/jni/android_os_MessageQueue.cpp

```cpp
static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);
}

void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {
    mPollEnv = env;
    mPollObj = pollObj;
    // 同样也是委托Looper进行处理
    mLooper-&gt;pollOnce(timeoutMillis);
    mPollObj = NULL;
    mPollEnv = NULL;
}
```

system/core/libutils/Looper.cpp

```cpp
int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    int result = 0;
    for (;;) {
    	// 获取操作实际上是从reponse队列中拿取的
        ...

        if (result != 0) {
            if (outFd != NULL) *outFd = 0;
            if (outEvents != NULL) *outEvents = 0;
            if (outData != NULL) *outData = NULL;
            return result;
        }

		// 本质上在循环的调用pollInner方法，直到获取到了结果
        result = pollInner(timeoutMillis);
    }
}

int Looper::pollInner(int timeoutMillis) {
	...

    // Poll.
    int result = POLL_WAKE;
    // 清空response队列
    mResponses.clear();
    mResponseIndex = 0;

    // We are about to idle.
    mPolling = true;

	// 初始化epoll_event
    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    // 使用epoll_wait调用的kernel去请求事件，kernel获取到事件后会通过mmap将epoll_event信息返回到native层
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    // No longer idling.
    mPolling = false;

    // Acquire lock.
    mLock.lock();
    
    ...

	// 获取到信息后，接下来就是读取了
    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeEventFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            }
        } else {
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;
                // 插入到response队列中供后续获取
                pushResponse(events, mRequests.valueAt(requestIndex));
            } 
        }
    }
Done: ;

    mNextMessageUptime = LLONG_MAX;
    while (mMessageEnvelopes.size() != 0) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
        if (messageEnvelope.uptime &lt;= now) {
            { // obtain handler
                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
                Message message = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = true;
                mLock.unlock();
                // 首先处理native层的Message
                handler-&gt;handleMessage(message);
            } // release handler
        }
    }

    // Release lock.
    mLock.unlock();
    ...
    return result;
}
```

native层`Looper.pollInner()`方法是获取Message的主要操作：

1. 调用epoll_wait在kernel中获取设备事件，该方法后续会做分析
2. 获取到事件后进行解析并插入到response队列中
3. 处理native事件

可以看到，该方法会首先处理native层的Message，也就是说Handler这套框架对于native的消息是优先派发的

## 设置同步分割栏: MessageQueue.postSyncBarrier()

同步分割栏的原理其实很简单，本质上就是通过创建一个target成员为NULL的Message并插入到消息队列中，这样在这个特殊的Message之后的消息就不会被处理了，只有当这个Message被移除后才会继续执行之后的Message

最经典的实现就是ViewRootImpl调用`scheduleTraversals`方法进行视图更新时的使用:

frameworks/base/core/java/android/view/ViewRootImpl.java

```java
void scheduleTraversals() {
    if (!mTraversalScheduled) {
        mTraversalScheduled = true;
        // 执行分割操作后会获取到分割令牌，使用它可以移除分割栏
        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
        // 发出一个有异步标志的Message，避免被分割
        mChoreographer.postCallback(
            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
        ...
    }
}
```

在执行`doTraversal`方法后，才会移出分割栏:

```java
void doTraversal() {
    if (mTraversalScheduled) {
        mTraversalScheduled = false;
		mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

        performTraversals();

        ...
    }
}
```

这样做的原因是，`doTraversal`的操作是通过Handler进行处理的，然而这个消息队列却是整个主线程公用的，比如说四大组件的各个生命周期的调用，然而`doTraversal`的内容是更新视图UI，这个任务无疑是最高优先级的。所以在这之前，需要确保队列中其它同步消息不会影响到它的执行

这里继续跟一下`MessageQueue.postSyncBarrier()`的实现:

frameworks/base/core/java/android/os/MessageQueue.java

```java
public int postSyncBarrier() {
    return postSyncBarrier(SystemClock.uptimeMillis());
}

private int postSyncBarrier(long when) {
    synchronized (this) {
        final int token = mNextBarrierToken++;
        final Message msg = Message.obtain();
        msg.markInUse();
        msg.when = when;
        msg.arg1 = token;
        // 注意这里，并没有为target成员进行初始化

        Message prev = null;
        Message p = mMessages;
        // 插入到队列中
        if (when != 0) {
            while (p != null &amp;&amp; p.when &lt;= when) {
                prev = p;
                p = p.next;
            }
        }
        if (prev != null) { // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        } else {
            msg.next = p;
            mMessages = msg;
        }
        return token;
    }
}
```

可以看到，设置分割栏和普通的post Message是一样的，不同的是target是空的

下面接着来看看分割栏真正起作用的地方:

frameworks/base/core/java/android/os/MessageQueue.java

```java
Message next() {
    ...
    for (;;) {
        ...
        // 进行队列遍历
       	Message msg = mMessages;
        if (msg != null &amp;&amp; msg.target == null) {
            do {
                prevMsg = msg;
                msg = msg.next;
            // 如果target为NULL，将会陷入这个循环，除非是有异步标志的消息才会跳出循环
            } while (msg != null &amp;&amp; !msg.isAsynchronous());
        }
        ...
    }
}
```

## 跨进程异步消息: Messenger

Messenger是Android开发中算是比较冷门的一种跨进程通信方式，它的实现是依托着Binder+Handler这两种技术的配合，使得跨进程调用后服务端任务能够在指定的线程中被执行

这种方式其实就类似于ActivityThread的binder call接收后，使用指定Handler去post消息是一样的，不同的在于Messenger的对其进行了封装，使得开发者可以轻松的实现而不需要更多的代码

原生有个典型实现的MessengerService，可以参考它的思路：" value="## 简介

Handler这套线程异步通信框架在Android中的地位是不亚于Binder的，因为其基础设计简单、涉及的知识面广、业务使用场景多等原因，十分适合应用层的初中级的工程师进行深入学习

这篇文章中我将分析Handler核心功能的源码，分析将贯穿着framework, native和kernel的知识点：

1. Handler发送异步消息原理
2. Looper派发消息原理
3. 消息分割栏的原理与视图绘制的运用
4. epoll_create, epoll_ctl, epoll_wait三部曲的源码分析
5. epoll中生产者与消费者模型的运用

同时按惯例，会在开篇给出总括全局的类图与架构图，方面阅读中定位理解与阅读后的回顾

## 设计图

### 类图

![](https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_class_diagram.jpg)

* Message: 消息的抽象
* Handler: 发送消息的工具类clo
* MessageQueue: 主要维护了消息队列，同时也是与native通信的中枢
* Looper: 循环获取消息并进行派发
* Messenger: 可以跨进程传输的消息抽象

### 架构图

![](https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_arch.jpg)

1. 一个APP中运行着多个线程，不同线程间可以互相拿到对方的Handler对象
2. MessageQueue和native直接通信，native中又和kernel通信，这样的调用链赋予了APP使用系统内核资源的能力
3. epoll机制在kernel中维护了一个链表与一颗红黑树是它效率优于poll与select的基础

## 发送跨线程异步消息: Handler.post()

使用Handler的前提是获取到它的引用对象，然后才能够在对应的MessageQueue的消息队列插入消息。能够这样做的根本原因在于，线程之间的内存是可以相互访问的，这也是Handler能够实现跨线程通信的基本原理之一

下面从最常用的`Handler.post()`方法入手，看看消息发送的实现原理，这里需要说明的一点是，使用Handler发送消息的花样很多，但最终都需要调用到`MessageQueue.enqueueMessage()`方法来实现，这里就不一一介绍API的使用了

frameworks/base/core/java/android/os/Handler.java

```java
public final boolean post(Runnable r)
{
    return  sendMessageDelayed(getPostMessage(r), 0);
}

public final boolean postAtTime(Runnable r, long uptimeMillis)
{
    return sendMessageAtTime(getPostMessage(r), uptimeMillis);
}

public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    // 这里获取到队列，队列是该线程唯一的，在Handler初始化时获取
    MessageQueue queue = mQueue;
    ...
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    // 判断是否为异步消息，异步消息将不会受到分割栏的影响
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    // 最终调用到MessageQueue去插入消息
    return queue.enqueueMessage(msg, uptimeMillis);
}
```

可以看到Handler只是一个类似于工具的类，最终的消息管理方面的操作还是需要委托给MessageQueue去做

frameworks/base/core/java/android/os/MessageQueue.java

```java
boolean enqueueMessage(Message msg, long when) {
    // 这里会强制target成员的设置，分割栏的插入不是调用这个方法实现的
    if (msg.target == null) {
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);

        // 因为不同的线程都可以调用这个方法，所以使用类锁保证消息队列的异步安全
        synchronized (this) {
            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                // 遍历消息队列，插入到合适的位置
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // 调用到native尝试唤醒对端设备
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
}
```

frameworks/base/core/jni/android_os_MessageQueue.cpp

```cpp
static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {
	// 通过ptr获取到NativeMessageQueue对象
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;wake();
}

void NativeMessageQueue::wake() {
	// 委托给native层的Looper进行处理
    mLooper-&gt;wake();
}
```

system/core/libutils/Looper.cpp

```cpp
void Looper::wake() {
    uint64_t inc = 1;
    // 向文件描述符为mWakeEventFd设备写入，以此来唤醒监听设备的epoll
    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));
    ...
}
```

总结一下消息发送的主要工作：

1. 在java层的消息队列中根据时间插入消息
2. 在native层，向对应的fd设备写入数据，以此来唤醒监听该设备的epoll

## 处理消息: Handler.handleMessage()

handleMessage完全是处于被动调用的状态，每当消息到来时，会从kernel依次调用的native，再到java层的Looper

这里直接看Looper是如何获取到消息，并调用handleMessage的，省去了`Looper.prepare()`代码的分析

frameworks/base/core/java/android/os/Looper.java

```java
public static void loop() {
    // 从ThreadLocal中取出之前放入的Looper对象
    final Looper me = myLooper();
    // 获取到队列
    final MessageQueue queue = me.mQueue;

    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        // 获取下一个消息，这个方法在没有消息时会产生阻塞，只有在消息到来时才会触发
        Message msg = queue.next(); // might block
        
        ...

        // 派发消息，最终会调用到Handler.handleMessage方法
        try {
            msg.target.dispatchMessage(msg);
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        
        ...
        
        // 回收Message
        msg.recycleUnchecked();
    }
}
```

继续看看MessageQueue.next的实现：

frameworks/base/core/java/android/os/MessageQueue.java

```java
Message next() {
	// mPtr实际上是NativeMesssageQueue的引用，方便在native层查询到MessageQueue
    final long ptr = mPtr;

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        // 调用native方法，之后调用到epoll_wait
        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // 消息分割栏，后面会做分析
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                // 如果当前时间没有已经就绪的message，那么重置poll事件的时间
                if (now &lt; msg.when) {
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;

                    msg.markInUse();
                    // 如果该消息已经就绪，那么将它返回给Looper进行派发
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
        }

        // 如果此次没有处理消息，则用来处理IdleHandler的操作，把优先级不高的操作放到这里去执行，尽量不浪费事件片
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
    }
}
```

核心操作`nativePollOnce`同样是在native层进行处理

frameworks/base/core/jni/android_os_MessageQueue.cpp

```cpp
static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);
}

void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {
    mPollEnv = env;
    mPollObj = pollObj;
    // 同样也是委托Looper进行处理
    mLooper-&gt;pollOnce(timeoutMillis);
    mPollObj = NULL;
    mPollEnv = NULL;
}
```

system/core/libutils/Looper.cpp

```cpp
int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    int result = 0;
    for (;;) {
    	// 获取操作实际上是从reponse队列中拿取的
        ...

        if (result != 0) {
            if (outFd != NULL) *outFd = 0;
            if (outEvents != NULL) *outEvents = 0;
            if (outData != NULL) *outData = NULL;
            return result;
        }

		// 本质上在循环的调用pollInner方法，直到获取到了结果
        result = pollInner(timeoutMillis);
    }
}

int Looper::pollInner(int timeoutMillis) {
	...

    // Poll.
    int result = POLL_WAKE;
    // 清空response队列
    mResponses.clear();
    mResponseIndex = 0;

    // We are about to idle.
    mPolling = true;

	// 初始化epoll_event
    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    // 使用epoll_wait调用的kernel去请求事件，kernel获取到事件后会通过mmap将epoll_event信息返回到native层
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    // No longer idling.
    mPolling = false;

    // Acquire lock.
    mLock.lock();
    
    ...

	// 获取到信息后，接下来就是读取了
    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeEventFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            }
        } else {
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;
                // 插入到response队列中供后续获取
                pushResponse(events, mRequests.valueAt(requestIndex));
            } 
        }
    }
Done: ;

    mNextMessageUptime = LLONG_MAX;
    while (mMessageEnvelopes.size() != 0) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
        if (messageEnvelope.uptime &lt;= now) {
            { // obtain handler
                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
                Message message = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = true;
                mLock.unlock();
                // 首先处理native层的Message
                handler-&gt;handleMessage(message);
            } // release handler
        }
    }

    // Release lock.
    mLock.unlock();
    ...
    return result;
}
```

native层`Looper.pollInner()`方法是获取Message的主要操作：

1. 调用epoll_wait在kernel中获取设备事件，该方法后续会做分析
2. 获取到事件后进行解析并插入到response队列中
3. 处理native事件

可以看到，该方法会首先处理native层的Message，也就是说Handler这套框架对于native的消息是优先派发的

## 设置同步分割栏: MessageQueue.postSyncBarrier()

同步分割栏的原理其实很简单，本质上就是通过创建一个target成员为NULL的Message并插入到消息队列中，这样在这个特殊的Message之后的消息就不会被处理了，只有当这个Message被移除后才会继续执行之后的Message

最经典的实现就是ViewRootImpl调用`scheduleTraversals`方法进行视图更新时的使用:

frameworks/base/core/java/android/view/ViewRootImpl.java

```java
void scheduleTraversals() {
    if (!mTraversalScheduled) {
        mTraversalScheduled = true;
        // 执行分割操作后会获取到分割令牌，使用它可以移除分割栏
        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
        // 发出一个有异步标志的Message，避免被分割
        mChoreographer.postCallback(
            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
        ...
    }
}
```

在执行`doTraversal`方法后，才会移出分割栏:

```java
void doTraversal() {
    if (mTraversalScheduled) {
        mTraversalScheduled = false;
		mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

        performTraversals();

        ...
    }
}
```

这样做的原因是，`doTraversal`的操作是通过Handler进行处理的，然而这个消息队列却是整个主线程公用的，比如说四大组件的各个生命周期的调用，然而`doTraversal`的内容是更新视图UI，这个任务无疑是最高优先级的。所以在这之前，需要确保队列中其它同步消息不会影响到它的执行

这里继续跟一下`MessageQueue.postSyncBarrier()`的实现:

frameworks/base/core/java/android/os/MessageQueue.java

```java
public int postSyncBarrier() {
    return postSyncBarrier(SystemClock.uptimeMillis());
}

private int postSyncBarrier(long when) {
    synchronized (this) {
        final int token = mNextBarrierToken++;
        final Message msg = Message.obtain();
        msg.markInUse();
        msg.when = when;
        msg.arg1 = token;
        // 注意这里，并没有为target成员进行初始化

        Message prev = null;
        Message p = mMessages;
        // 插入到队列中
        if (when != 0) {
            while (p != null &amp;&amp; p.when &lt;= when) {
                prev = p;
                p = p.next;
            }
        }
        if (prev != null) { // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        } else {
            msg.next = p;
            mMessages = msg;
        }
        return token;
    }
}
```

可以看到，设置分割栏和普通的post Message是一样的，不同的是target是空的

下面接着来看看分割栏真正起作用的地方:

frameworks/base/core/java/android/os/MessageQueue.java

```java
Message next() {
    ...
    for (;;) {
        ...
        // 进行队列遍历
       	Message msg = mMessages;
        if (msg != null &amp;&amp; msg.target == null) {
            do {
                prevMsg = msg;
                msg = msg.next;
            // 如果target为NULL，将会陷入这个循环，除非是有异步标志的消息才会跳出循环
            } while (msg != null &amp;&amp; !msg.isAsynchronous());
        }
        ...
    }
}
```

## 跨进程异步消息: Messenger

Messenger是Android开发中算是比较冷门的一种跨进程通信方式，它的实现是依托着Binder+Handler这两种技术的配合，使得跨进程调用后服务端任务能够在指定的线程中被执行

这种方式其实就类似于ActivityThread的binder call接收后，使用指定Handler去post消息是一样的，不同的在于Messenger的对其进行了封装，使得开发者可以轻松的实现而不需要更多的代码

原生有个典型实现的MessengerService，可以参考它的思路：

frameworks/base/core/tests/coretests/src/android/os/MessengerService.java

```java
public class MessengerService extends Service {
    private final Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            Message reply = Message.obtain();
            reply.copyFrom(msg);
            try {
            	// 这里的replyTo的mTarget实际上是对端的binder proxy，用以实现回调的功能
                msg.replyTo.send(reply);
            } catch (RemoteException e) {
            }
        }
    };
    
    // 创建一个Messenger，mTarget将会创建一个binder stub，服务方法运行在mHandler所在线程
    private final Messenger mMessenger = new Messenger(mHandler);
    
    public MessengerService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
    	// 返回的是被创建的Messenger服务binder句柄
        return mMessenger.getBinder();
    }
}
```

1. 服务端可以通过继承MessengerService，定义自己的业务
2. 客户端通过bind该service，可以获取Messenger的binder proxy句柄，从而实现通信。调用到服务端后，操作将会运行在mHandler所在线程
3. replyTo是客户端指定的，用来接受服务端的回复

## 实现基础: epoll

epoll和select和poll一样都是I/O多路复用技术，和它们不同的是，epoll只关心&quot;活跃&quot;的链接，不需要遍历全部的描述符集合，能够处理大量的链接请求



以下是一个使用epoll的典型代码示例，主要分为三部：

1. 使用epoll_create创建epoll的fd
2. 使用epoll_ctl将需要监听的fd添加到epoll中
3. 使用epoll_wait等待事件

```c
struct epoll_event ev, events[10];
int listen_sock, conn_sock, nfds, epollfd;

// 创建epoll的文件描述符  
epollfd = epoll_create1(0);
if (epollfd == -1) {
    perror(&quot;epoll_create1&quot;);
    exit(EXIT_FAILURE);
}

// 将我们需要监听的文件描述符和事件通过epoll_ctl加入到epoll描述符中
ev.events = EPOLLIN;
ev.data.fd = listen_sock;
if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) {
    perror(&quot;epoll_ctl: listen_sock&quot;);
    exit(EXIT_FAILURE);
}

for (;;) {
    // 等待事件的发生
    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
    if (nfds == -1) {
        perror(&quot;epoll_wait&quot;);
        exit(EXIT_FAILURE);
    }

	// 监听到事件，处理事件
    ...
}
```

epoll的实现很简单，简单到所有的主要逻辑都在单个文件中实现，文件路径在`kernel/msm-3.18/fs/eventpoll.c`

下面接着分析epoll各个重要函数的源码

### epoll 初始化

在使用epoll之前，系统需要在启动期间对epoll的基础设施进行初始化

```c
static int __init eventpoll_init(void)
{
	struct sysinfo si;

	// 获取系统内存状态
	si_meminfo(&amp;si);
	// 根据系统内存配置设置单个用户可见监听的最大epoll个数
	max_user_watches = (((si.totalram - si.totalhigh) / 25) &lt;&lt; PAGE_SHIFT) / EP_ITEM_COST;

	// 初始化调用队列，方便检查是否超过最大嵌套次数
	ep_nested_calls_init(&amp;poll_loop_ncalls);
	ep_nested_calls_init(&amp;poll_safewake_ncalls);
	ep_nested_calls_init(&amp;poll_readywalk_ncalls);

	// 创建用于分配epitem数据结构的的SLAB缓存
	epi_cache = kmem_cache_create(&quot;eventpoll_epi&quot;, sizeof(struct epitem),
			0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);

	// 创建用于分配eppoll_entry数据结构的SLAB缓存
	pwq_cache = kmem_cache_create(&quot;eventpoll_pwq&quot;,
			sizeof(struct eppoll_entry), 0, SLAB_PANIC, NULL);

	return 0;
}
// 在系统启动过程中，init进程设备初始化时对epoll进行初始化
fs_initcall(eventpoll_init);
```

epoll 初始化期间主要完成的三个工作:

1. 根据内存配置，初始化单个用户最大可见听epoll个数
2. 初始化调用队列，以此来判断嵌套调用是超过上限
3. 初始化SLAB内存缓存，以此来提升epoll使用内存的效率

### epoll_create

在native Looper.cpp的实现中，epoll_create的调用函数用以创建一个epoll，但是在内核源码中并没有直接发现epoll_create之类的函数

查阅资料后发现，内核将epoll系列的函数都使用了SYSCALL_DEFINE宏调用来实现了，SYSCALL_DEFINE后的数字x代表了该函数拥有x个参数，之所以使用这种方式来声明函数是为了修复64位Linux系统上的CVE-2009-2009漏洞

```c
// 为了阅读源码的便捷性，可以直接将该宏调用看成 epoll_create(int flags);
SYSCALL_DEFINE1(epoll_create1, int, flags)
{
	int error, fd;
	struct eventpoll *ep = NULL;
	struct file *file;

	// 初始化eventpoll结构
	error = ep_alloc(&amp;ep);
	// 获取一个没有使用过的fd
	fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));
	
	// 创建eventpoll文件，file_operations为eventpoll_fops
	// 同时将ep设置到file-&gt;private_data中
	file = anon_inode_getfile(&quot;[eventpoll]&quot;, &amp;eventpoll_fops, ep,
				 O_RDWR | (flags &amp; O_CLOEXEC));
	
	ep-&gt;file = file;
	// 将fd与文件进行关联
	fd_install(fd, file);
	return fd;

out_free_fd:
	put_unused_fd(fd);
out_free_ep:
	ep_free(ep);
	return error;
}
```

epoll_create的主要做了两个工作：

1. 新建并初始化一个epollpoll结构
2. 创建eventpoll文件、获取一个空闲fd，并将两者进行关联

### epoll_ctl

```c
// epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,
		struct epoll_event __user *, event)
{
	int error;
	int full_check = 0;
	struct fd f, tf;
	struct eventpoll *ep;
	struct epitem *epi;
	struct epoll_event epds;
	struct eventpoll *tep = NULL;

	error = -EFAULT;
	if (ep_op_has_event(op) &amp;&amp;
		// 将epoll_event信息使用mmap从native拷贝到kernel
	    copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))
		goto error_return;

	// 获取mEpollFd, mWakeEventFd对应文件
	f = fdget(epfd);
	tf = fdget(fd);

	// 从文件的private_data中获取到eventpoll
	ep = f.file-&gt;private_data;

	mutex_lock_nested(&amp;ep-&gt;mtx, 0);
	...
	// 通过file, fd在eventpoll的红黑树中进行查询，看是否存在已经保存的eventitem
	epi = ep_find(ep, tf.file, fd);

	error = -EINVAL;
	// 进行op操作分流
	switch (op) {
	case EPOLL_CTL_ADD:
		if (!epi) {
			// 如果未查询到，则创建并插入新的eventitem
			epds.events |= POLLERR | POLLHUP;
			error = ep_insert(ep, &amp;epds, tf.file, fd, full_check);
		} else
			error = -EEXIST;
		break;
	case EPOLL_CTL_DEL:
		if (epi)
			// 如果查询到，则移除该eventitem
			error = ep_remove(ep, epi);
		else
			error = -ENOENT;
		break;
	case EPOLL_CTL_MOD:
		if (epi) {
			// 如果查询到，则进行替换
			epds.events |= POLLERR | POLLHUP;
			error = ep_modify(ep, epi, &amp;epds);
		} else
			error = -ENOENT;
		break;
	}
	if (tep != NULL)
		mutex_unlock(&amp;tep-&gt;mtx);
	mutex_unlock(&amp;ep-&gt;mtx);

error_tgt_fput:
	if (full_check)
		mutex_unlock(&amp;epmutex);

	fdput(tf);
error_fput:
	fdput(f);
error_return:

	return error;
}
```

epoll_ctl主要做了两个工作：

1. 将epoll_event信息使用mmap拷贝到内核中
2. 通过fd获取到对应的file文件，并通过private_data获取到eventpoll
3. 通过file,fd在eventpoll中进行查询，看是否存在对应的eventitem
4. 根据查询到的eventitem进行对应的操作

这里详细分析下`ep_insert`方法:

```c
static int ep_insert(struct eventpoll *ep, struct epoll_event *event,
		     struct file *tfile, int fd, int full_check)
{
	int error, revents, pwake = 0;
	unsigned long flags;
	long user_watches;
	struct epitem *epi;
	struct ep_pqueue epq;
	
	// 使用SLAB内存分配器创建eventitem
	if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))
		return -ENOMEM;

	// 初始化链表节点
	INIT_LIST_HEAD(&amp;epi-&gt;rdllink);
	INIT_LIST_HEAD(&amp;epi-&gt;fllink);
	INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);
	// 初始化基础属性
	epi-&gt;ep = ep;
	ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);
	epi-&gt;event = *event;
	epi-&gt;nwait = 0;
	epi-&gt;next = EP_UNACTIVE_PTR;

	// 初始化poll表，并注册回调函数ep_ptable_queue_proc
	epq.epi = epi;
	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);

	// 调用被插入文件的poll方法，最终会将当前epollitem放入到ready list并唤醒eventpoll中的等待进程
	revents = ep_item_poll(epi, &amp;epq.pt);

	/* Add the current item to the list of active epoll hook for this file */
	spin_lock(&amp;tfile-&gt;f_lock);
	// 将fllink加入到文件的f_ep_links列表中作为子项
	list_add_tail_rcu(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);
	spin_unlock(&amp;tfile-&gt;f_lock);

	// 将epollitem的rbn红黑树节点插入到eventpoll中的rbr红黑树中
	// 注意一点的是，节点的是根据epoll_filefd来比对的
	ep_rbtree_insert(ep, epi);

	spin_lock_irqsave(&amp;ep-&gt;lock, flags);

	if ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) {
		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);
		ep_pm_stay_awake(epi);

		// 唤醒该队列
		if (waitqueue_active(&amp;ep-&gt;wq))
			wake_up_locked(&amp;ep-&gt;wq);
		if (waitqueue_active(&amp;ep-&gt;poll_wait))
			pwake++;
	}

	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);

	atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);

	// 唤醒并调用该队列中的事件
	if (pwake)
		ep_poll_safewake(&amp;ep-&gt;poll_wait);

	return 0;
...
}
```

epoll_ctl主要做了三个工作：

1. 创建并初始化eventitem
2. 为poll_wait函数初始化，当设备唤醒时会执行回调函数
3. 检查当前设备状态，如果已经就绪那么直接唤醒等待队列

### epoll_wait

```c
// epoll_wait(int epfd, epoll_event *events, int maxevents, int timeout)
SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events, int, maxevents, int, timeout)
{
	int error;
	struct fd f;
	struct eventpoll *ep;

	// 通过fd获取到文件信息
	f = fdget(epfd);

	// 通过private_data获取到eventpoll
	ep = f.file-&gt;private_data;

	// 调用ep_poll获取就绪的事件，并将它们派发到接收者的事件缓冲中
	error = ep_poll(ep, events, maxevents, timeout);

error_fput:
	fdput(f);
	return error;
}
```

epoll_wait的操作很简单，通过fd检索到相关eventpoll后马上调用核心函数`ep_poll`，这里详细分析一下：

```c
static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events, int maxevents, long timeout)
{
	int res = 0, eavail, timed_out = 0;
	unsigned long flags;
	long slack = 0;
	wait_queue_t wait;
	ktime_t expires, *to = NULL;

	if (timeout &gt; 0) {
		struct timespec end_time = ep_set_mstimeout(timeout);

		slack = select_estimate_accuracy(&amp;end_time);
		to = &amp;expires;
		*to = timespec_to_ktime(end_time);
	} else if (timeout == 0) {
		// 如果未设置超时事件，则直接获取事件，不进行阻塞
		timed_out = 1;
		spin_lock_irqsave(&amp;ep-&gt;lock, flags);
		goto check_events;
	}

fetch_events:
	spin_lock_irqsave(&amp;ep-&gt;lock, flags);

	if (!ep_events_available(ep)) {
		// 使用队列进行睡眠，直到ep_poll_callback被调用，队列被唤醒，才会接着执行下去
		init_waitqueue_entry(&amp;wait, current);
		__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);

		for (;;) {
			set_current_state(TASK_INTERRUPTIBLE);
			// 如果事件到来则退出循环
			if (ep_events_available(ep) || timed_out)
				break;
			if (signal_pending(current)) {
				res = -EINTR;
				break;
			}

			spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);
			if (!freezable_schedule_hrtimeout_range(to, slack,
								HRTIMER_MODE_ABS))
				timed_out = 1;

			spin_lock_irqsave(&amp;ep-&gt;lock, flags);
		}
		__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);

		set_current_state(TASK_RUNNING);
	}
check_events:
	// 是否存在入队的事件
	eavail = ep_events_available(ep);

	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);

	// 取出事件并发送到客户端进程
	if (!res &amp;&amp; eavail &amp;&amp;
	    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)
		goto fetch_events;

	return res;
}
```

ep_poll的主要操作在于从eventpoll中取出已经准备就绪的eventitem，随后调用`ep_send_events`，通过timeout参数判断是否需要阻塞以及需要阻塞的时间

```c
static int ep_send_events(struct eventpoll *ep,
			  struct epoll_event __user *events, int maxevents)
{
	struct ep_send_events_data esed;

	esed.maxevents = maxevents;
	esed.events = events;

	// ep_send_events_proc 为扫描回调函数
	return ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0, false);
}

static int ep_scan_ready_list(struct eventpoll *ep,
			      int (*sproc)(struct eventpoll *,
					   struct list_head *, void *),
			      void *priv, int depth, bool ep_locked)
{
	int error, pwake = 0;
	unsigned long flags;
	struct epitem *epi, *nepi;
	LIST_HEAD(txlist);
	...
	// 调用ep_send_events_proc进行回调
	error = (*sproc)(ep, &amp;txlist, priv);
	...
	return error;
}

static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head, void *priv)
{
	struct ep_send_events_data *esed = priv;
	int eventcnt;
	unsigned int revents;
	struct epitem *epi;
	struct epoll_event __user *uevent;
	struct wakeup_source *ws;
	poll_table pt;

	init_poll_funcptr(&amp;pt, NULL);
	for (eventcnt = 0, uevent = esed-&gt;events;
	     !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) {
	    // 从rdlink列表中获取到epollitem
		epi = list_first_entry(head, struct epitem, rdllink);
		
		ws = ep_wakeup_source(epi);
		if (ws) {
			if (ws-&gt;active)
				__pm_stay_awake(ep-&gt;ws);
			__pm_relax(ws);
		}

		list_del_init(&amp;epi-&gt;rdllink);

		// 从设备中读取事件
		revents = ep_item_poll(epi, &amp;pt);

		if (revents) {
			// 使用mmap将事件发送到客户端
			if (__put_user(revents, &amp;uevent-&gt;events) ||
			    __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) {
				list_add(&amp;epi-&gt;rdllink, head);
				ep_pm_stay_awake(epi);
				return eventcnt ? eventcnt : -EFAULT;
			}
			...
		}
	}

	return eventcnt;
}
```

### epoll中的生产者消费者模型

* 生产者: 由`epoll_ctl`最终调用的`ep_insert`触发，在驱动唤醒等待队列后会调用`ep_poll_callback`方法将epollitem添加到epollevent的`rdllist`中
* 消费者: 由`epoll_wait`最终调用的`ep_poll`触发，在等待队列响应后会继续执行，从`rdllist`中取出epoll_item，随后读取设备


" link_users="{}" data-body="## 简介

Handler这套线程异步通信框架在Android中的地位是不亚于Binder的，因为其基础设计简单、涉及的知识面广、业务使用场景多等原因，十分适合应用层的初中级的工程师进行深入学习

这篇文章中我将分析Handler核心功能的源码，分析将贯穿着framework, native和kernel的知识点：

1. Handler发送异步消息原理
2. Looper派发消息原理
3. 消息分割栏的原理与视图绘制的运用
4. epoll_create, epoll_ctl, epoll_wait三部曲的源码分析
5. epoll中生产者与消费者模型的运用

同时按惯例，会在开篇给出总括全局的类图与架构图，方面阅读中定位理解与阅读后的回顾

## 设计图

### 类图

![](https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_class_diagram.jpg)

* Message: 消息的抽象
* Handler: 发送消息的工具类clo
* MessageQueue: 主要维护了消息队列，同时也是与native通信的中枢
* Looper: 循环获取消息并进行派发
* Messenger: 可以跨进程传输的消息抽象

### 架构图

![](https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_arch.jpg)

1. 一个APP中运行着多个线程，不同线程间可以互相拿到对方的Handler对象
2. MessageQueue和native直接通信，native中又和kernel通信，这样的调用链赋予了APP使用系统内核资源的能力
3. epoll机制在kernel中维护了一个链表与一颗红黑树是它效率优于poll与select的基础

## 发送跨线程异步消息: Handler.post()

使用Handler的前提是获取到它的引用对象，然后才能够在对应的MessageQueue的消息队列插入消息。能够这样做的根本原因在于，线程之间的内存是可以相互访问的，这也是Handler能够实现跨线程通信的基本原理之一

下面从最常用的`Handler.post()`方法入手，看看消息发送的实现原理，这里需要说明的一点是，使用Handler发送消息的花样很多，但最终都需要调用到`MessageQueue.enqueueMessage()`方法来实现，这里就不一一介绍API的使用了

frameworks/base/core/java/android/os/Handler.java

```java
public final boolean post(Runnable r)
{
    return  sendMessageDelayed(getPostMessage(r), 0);
}

public final boolean postAtTime(Runnable r, long uptimeMillis)
{
    return sendMessageAtTime(getPostMessage(r), uptimeMillis);
}

public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    // 这里获取到队列，队列是该线程唯一的，在Handler初始化时获取
    MessageQueue queue = mQueue;
    ...
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    // 判断是否为异步消息，异步消息将不会受到分割栏的影响
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    // 最终调用到MessageQueue去插入消息
    return queue.enqueueMessage(msg, uptimeMillis);
}
```

可以看到Handler只是一个类似于工具的类，最终的消息管理方面的操作还是需要委托给MessageQueue去做

frameworks/base/core/java/android/os/MessageQueue.java

```java
boolean enqueueMessage(Message msg, long when) {
    // 这里会强制target成员的设置，分割栏的插入不是调用这个方法实现的
    if (msg.target == null) {
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);

        // 因为不同的线程都可以调用这个方法，所以使用类锁保证消息队列的异步安全
        synchronized (this) {
            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                // 遍历消息队列，插入到合适的位置
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // 调用到native尝试唤醒对端设备
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
}
```

frameworks/base/core/jni/android_os_MessageQueue.cpp

```cpp
static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {
	// 通过ptr获取到NativeMessageQueue对象
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;wake();
}

void NativeMessageQueue::wake() {
	// 委托给native层的Looper进行处理
    mLooper-&gt;wake();
}
```

system/core/libutils/Looper.cpp

```cpp
void Looper::wake() {
    uint64_t inc = 1;
    // 向文件描述符为mWakeEventFd设备写入，以此来唤醒监听设备的epoll
    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));
    ...
}
```

总结一下消息发送的主要工作：

1. 在java层的消息队列中根据时间插入消息
2. 在native层，向对应的fd设备写入数据，以此来唤醒监听该设备的epoll

## 处理消息: Handler.handleMessage()

handleMessage完全是处于被动调用的状态，每当消息到来时，会从kernel依次调用的native，再到java层的Looper

这里直接看Looper是如何获取到消息，并调用handleMessage的，省去了`Looper.prepare()`代码的分析

frameworks/base/core/java/android/os/Looper.java

```java
public static void loop() {
    // 从ThreadLocal中取出之前放入的Looper对象
    final Looper me = myLooper();
    // 获取到队列
    final MessageQueue queue = me.mQueue;

    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        // 获取下一个消息，这个方法在没有消息时会产生阻塞，只有在消息到来时才会触发
        Message msg = queue.next(); // might block
        
        ...

        // 派发消息，最终会调用到Handler.handleMessage方法
        try {
            msg.target.dispatchMessage(msg);
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        
        ...
        
        // 回收Message
        msg.recycleUnchecked();
    }
}
```

继续看看MessageQueue.next的实现：

frameworks/base/core/java/android/os/MessageQueue.java

```java
Message next() {
	// mPtr实际上是NativeMesssageQueue的引用，方便在native层查询到MessageQueue
    final long ptr = mPtr;

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        // 调用native方法，之后调用到epoll_wait
        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // 消息分割栏，后面会做分析
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                // 如果当前时间没有已经就绪的message，那么重置poll事件的时间
                if (now &lt; msg.when) {
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;

                    msg.markInUse();
                    // 如果该消息已经就绪，那么将它返回给Looper进行派发
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }
        }

        // 如果此次没有处理消息，则用来处理IdleHandler的操作，把优先级不高的操作放到这里去执行，尽量不浪费事件片
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
    }
}
```

核心操作`nativePollOnce`同样是在native层进行处理

frameworks/base/core/jni/android_os_MessageQueue.cpp

```cpp
static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);
}

void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {
    mPollEnv = env;
    mPollObj = pollObj;
    // 同样也是委托Looper进行处理
    mLooper-&gt;pollOnce(timeoutMillis);
    mPollObj = NULL;
    mPollEnv = NULL;
}
```

system/core/libutils/Looper.cpp

```cpp
int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    int result = 0;
    for (;;) {
    	// 获取操作实际上是从reponse队列中拿取的
        ...

        if (result != 0) {
            if (outFd != NULL) *outFd = 0;
            if (outEvents != NULL) *outEvents = 0;
            if (outData != NULL) *outData = NULL;
            return result;
        }

		// 本质上在循环的调用pollInner方法，直到获取到了结果
        result = pollInner(timeoutMillis);
    }
}

int Looper::pollInner(int timeoutMillis) {
	...

    // Poll.
    int result = POLL_WAKE;
    // 清空response队列
    mResponses.clear();
    mResponseIndex = 0;

    // We are about to idle.
    mPolling = true;

	// 初始化epoll_event
    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    // 使用epoll_wait调用的kernel去请求事件，kernel获取到事件后会通过mmap将epoll_event信息返回到native层
    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    // No longer idling.
    mPolling = false;

    // Acquire lock.
    mLock.lock();
    
    ...

	// 获取到信息后，接下来就是读取了
    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeEventFd) {
            if (epollEvents &amp; EPOLLIN) {
                awoken();
            }
        } else {
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;
                // 插入到response队列中供后续获取
                pushResponse(events, mRequests.valueAt(requestIndex));
            } 
        }
    }
Done: ;

    mNextMessageUptime = LLONG_MAX;
    while (mMessageEnvelopes.size() != 0) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
        if (messageEnvelope.uptime &lt;= now) {
            { // obtain handler
                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
                Message message = messageEnvelope.message;
                mMessageEnvelopes.removeAt(0);
                mSendingMessage = true;
                mLock.unlock();
                // 首先处理native层的Message
                handler-&gt;handleMessage(message);
            } // release handler
        }
    }

    // Release lock.
    mLock.unlock();
    ...
    return result;
}
```

native层`Looper.pollInner()`方法是获取Message的主要操作：

1. 调用epoll_wait在kernel中获取设备事件，该方法后续会做分析
2. 获取到事件后进行解析并插入到response队列中
3. 处理native事件

可以看到，该方法会首先处理native层的Message，也就是说Handler这套框架对于native的消息是优先派发的

## 设置同步分割栏: MessageQueue.postSyncBarrier()

同步分割栏的原理其实很简单，本质上就是通过创建一个target成员为NULL的Message并插入到消息队列中，这样在这个特殊的Message之后的消息就不会被处理了，只有当这个Message被移除后才会继续执行之后的Message

最经典的实现就是ViewRootImpl调用`scheduleTraversals`方法进行视图更新时的使用:

frameworks/base/core/java/android/view/ViewRootImpl.java

```java
void scheduleTraversals() {
    if (!mTraversalScheduled) {
        mTraversalScheduled = true;
        // 执行分割操作后会获取到分割令牌，使用它可以移除分割栏
        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
        // 发出一个有异步标志的Message，避免被分割
        mChoreographer.postCallback(
            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
        ...
    }
}
```

在执行`doTraversal`方法后，才会移出分割栏:

```java
void doTraversal() {
    if (mTraversalScheduled) {
        mTraversalScheduled = false;
		mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

        performTraversals();

        ...
    }
}
```

这样做的原因是，`doTraversal`的操作是通过Handler进行处理的，然而这个消息队列却是整个主线程公用的，比如说四大组件的各个生命周期的调用，然而`doTraversal`的内容是更新视图UI，这个任务无疑是最高优先级的。所以在这之前，需要确保队列中其它同步消息不会影响到它的执行

这里继续跟一下`MessageQueue.postSyncBarrier()`的实现:

frameworks/base/core/java/android/os/MessageQueue.java

```java
public int postSyncBarrier() {
    return postSyncBarrier(SystemClock.uptimeMillis());
}

private int postSyncBarrier(long when) {
    synchronized (this) {
        final int token = mNextBarrierToken++;
        final Message msg = Message.obtain();
        msg.markInUse();
        msg.when = when;
        msg.arg1 = token;
        // 注意这里，并没有为target成员进行初始化

        Message prev = null;
        Message p = mMessages;
        // 插入到队列中
        if (when != 0) {
            while (p != null &amp;&amp; p.when &lt;= when) {
                prev = p;
                p = p.next;
            }
        }
        if (prev != null) { // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        } else {
            msg.next = p;
            mMessages = msg;
        }
        return token;
    }
}
```

可以看到，设置分割栏和普通的post Message是一样的，不同的是target是空的

下面接着来看看分割栏真正起作用的地方:

frameworks/base/core/java/android/os/MessageQueue.java

```java
Message next() {
    ...
    for (;;) {
        ...
        // 进行队列遍历
       	Message msg = mMessages;
        if (msg != null &amp;&amp; msg.target == null) {
            do {
                prevMsg = msg;
                msg = msg.next;
            // 如果target为NULL，将会陷入这个循环，除非是有异步标志的消息才会跳出循环
            } while (msg != null &amp;&amp; !msg.isAsynchronous());
        }
        ...
    }
}
```

## 跨进程异步消息: Messenger

Messenger是Android开发中算是比较冷门的一种跨进程通信方式，它的实现是依托着Binder+Handler这两种技术的配合，使得跨进程调用后服务端任务能够在指定的线程中被执行

这种方式其实就类似于ActivityThread的binder call接收后，使用指定Handler去post消息是一样的，不同的在于Messenger的对其进行了封装，使得开发者可以轻松的实现而不需要更多的代码

原生有个典型实现的MessengerService，可以参考它的思路：

frameworks/base/core/tests/coretests/src/android/os/MessengerService.java

```java
public class MessengerService extends Service {
    private final Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            Message reply = Message.obtain();
            reply.copyFrom(msg);
            try {
            	// 这里的replyTo的mTarget实际上是对端的binder proxy，用以实现回调的功能
                msg.replyTo.send(reply);
            } catch (RemoteException e) {
            }
        }
    };
    
    // 创建一个Messenger，mTarget将会创建一个binder stub，服务方法运行在mHandler所在线程
    private final Messenger mMessenger = new Messenger(mHandler);
    
    public MessengerService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
    	// 返回的是被创建的Messenger服务binder句柄
        return mMessenger.getBinder();
    }
}
```

1. 服务端可以通过继承MessengerService，定义自己的业务
2. 客户端通过bind该service，可以获取Messenger的binder proxy句柄，从而实现通信。调用到服务端后，操作将会运行在mHandler所在线程
3. replyTo是客户端指定的，用来接受服务端的回复

## 实现基础: epoll

epoll和select和poll一样都是I/O多路复用技术，和它们不同的是，epoll只关心&quot;活跃&quot;的链接，不需要遍历全部的描述符集合，能够处理大量的链接请求



以下是一个使用epoll的典型代码示例，主要分为三部：

1. 使用epoll_create创建epoll的fd
2. 使用epoll_ctl将需要监听的fd添加到epoll中
3. 使用epoll_wait等待事件

```c
struct epoll_event ev, events[10];
int listen_sock, conn_sock, nfds, epollfd;

// 创建epoll的文件描述符  
epollfd = epoll_create1(0);
if (epollfd == -1) {
    perror(&quot;epoll_create1&quot;);
    exit(EXIT_FAILURE);
}

// 将我们需要监听的文件描述符和事件通过epoll_ctl加入到epoll描述符中
ev.events = EPOLLIN;
ev.data.fd = listen_sock;
if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) {
    perror(&quot;epoll_ctl: listen_sock&quot;);
    exit(EXIT_FAILURE);
}

for (;;) {
    // 等待事件的发生
    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);
    if (nfds == -1) {
        perror(&quot;epoll_wait&quot;);
        exit(EXIT_FAILURE);
    }

	// 监听到事件，处理事件
    ...
}
```

epoll的实现很简单，简单到所有的主要逻辑都在单个文件中实现，文件路径在`kernel/msm-3.18/fs/eventpoll.c`

下面接着分析epoll各个重要函数的源码

### epoll 初始化

在使用epoll之前，系统需要在启动期间对epoll的基础设施进行初始化

```c
static int __init eventpoll_init(void)
{
	struct sysinfo si;

	// 获取系统内存状态
	si_meminfo(&amp;si);
	// 根据系统内存配置设置单个用户可见监听的最大epoll个数
	max_user_watches = (((si.totalram - si.totalhigh) / 25) &lt;&lt; PAGE_SHIFT) / EP_ITEM_COST;

	// 初始化调用队列，方便检查是否超过最大嵌套次数
	ep_nested_calls_init(&amp;poll_loop_ncalls);
	ep_nested_calls_init(&amp;poll_safewake_ncalls);
	ep_nested_calls_init(&amp;poll_readywalk_ncalls);

	// 创建用于分配epitem数据结构的的SLAB缓存
	epi_cache = kmem_cache_create(&quot;eventpoll_epi&quot;, sizeof(struct epitem),
			0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);

	// 创建用于分配eppoll_entry数据结构的SLAB缓存
	pwq_cache = kmem_cache_create(&quot;eventpoll_pwq&quot;,
			sizeof(struct eppoll_entry), 0, SLAB_PANIC, NULL);

	return 0;
}
// 在系统启动过程中，init进程设备初始化时对epoll进行初始化
fs_initcall(eventpoll_init);
```

epoll 初始化期间主要完成的三个工作:

1. 根据内存配置，初始化单个用户最大可见听epoll个数
2. 初始化调用队列，以此来判断嵌套调用是超过上限
3. 初始化SLAB内存缓存，以此来提升epoll使用内存的效率

### epoll_create

在native Looper.cpp的实现中，epoll_create的调用函数用以创建一个epoll，但是在内核源码中并没有直接发现epoll_create之类的函数

查阅资料后发现，内核将epoll系列的函数都使用了SYSCALL_DEFINE宏调用来实现了，SYSCALL_DEFINE后的数字x代表了该函数拥有x个参数，之所以使用这种方式来声明函数是为了修复64位Linux系统上的CVE-2009-2009漏洞

```c
// 为了阅读源码的便捷性，可以直接将该宏调用看成 epoll_create(int flags);
SYSCALL_DEFINE1(epoll_create1, int, flags)
{
	int error, fd;
	struct eventpoll *ep = NULL;
	struct file *file;

	// 初始化eventpoll结构
	error = ep_alloc(&amp;ep);
	// 获取一个没有使用过的fd
	fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));
	
	// 创建eventpoll文件，file_operations为eventpoll_fops
	// 同时将ep设置到file-&gt;private_data中
	file = anon_inode_getfile(&quot;[eventpoll]&quot;, &amp;eventpoll_fops, ep,
				 O_RDWR | (flags &amp; O_CLOEXEC));
	
	ep-&gt;file = file;
	// 将fd与文件进行关联
	fd_install(fd, file);
	return fd;

out_free_fd:
	put_unused_fd(fd);
out_free_ep:
	ep_free(ep);
	return error;
}
```

epoll_create的主要做了两个工作：

1. 新建并初始化一个epollpoll结构
2. 创建eventpoll文件、获取一个空闲fd，并将两者进行关联

### epoll_ctl

```c
// epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,
		struct epoll_event __user *, event)
{
	int error;
	int full_check = 0;
	struct fd f, tf;
	struct eventpoll *ep;
	struct epitem *epi;
	struct epoll_event epds;
	struct eventpoll *tep = NULL;

	error = -EFAULT;
	if (ep_op_has_event(op) &amp;&amp;
		// 将epoll_event信息使用mmap从native拷贝到kernel
	    copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))
		goto error_return;

	// 获取mEpollFd, mWakeEventFd对应文件
	f = fdget(epfd);
	tf = fdget(fd);

	// 从文件的private_data中获取到eventpoll
	ep = f.file-&gt;private_data;

	mutex_lock_nested(&amp;ep-&gt;mtx, 0);
	...
	// 通过file, fd在eventpoll的红黑树中进行查询，看是否存在已经保存的eventitem
	epi = ep_find(ep, tf.file, fd);

	error = -EINVAL;
	// 进行op操作分流
	switch (op) {
	case EPOLL_CTL_ADD:
		if (!epi) {
			// 如果未查询到，则创建并插入新的eventitem
			epds.events |= POLLERR | POLLHUP;
			error = ep_insert(ep, &amp;epds, tf.file, fd, full_check);
		} else
			error = -EEXIST;
		break;
	case EPOLL_CTL_DEL:
		if (epi)
			// 如果查询到，则移除该eventitem
			error = ep_remove(ep, epi);
		else
			error = -ENOENT;
		break;
	case EPOLL_CTL_MOD:
		if (epi) {
			// 如果查询到，则进行替换
			epds.events |= POLLERR | POLLHUP;
			error = ep_modify(ep, epi, &amp;epds);
		} else
			error = -ENOENT;
		break;
	}
	if (tep != NULL)
		mutex_unlock(&amp;tep-&gt;mtx);
	mutex_unlock(&amp;ep-&gt;mtx);

error_tgt_fput:
	if (full_check)
		mutex_unlock(&amp;epmutex);

	fdput(tf);
error_fput:
	fdput(f);
error_return:

	return error;
}
```

epoll_ctl主要做了两个工作：

1. 将epoll_event信息使用mmap拷贝到内核中
2. 通过fd获取到对应的file文件，并通过private_data获取到eventpoll
3. 通过file,fd在eventpoll中进行查询，看是否存在对应的eventitem
4. 根据查询到的eventitem进行对应的操作

这里详细分析下`ep_insert`方法:

```c
static int ep_insert(struct eventpoll *ep, struct epoll_event *event,
		     struct file *tfile, int fd, int full_check)
{
	int error, revents, pwake = 0;
	unsigned long flags;
	long user_watches;
	struct epitem *epi;
	struct ep_pqueue epq;
	
	// 使用SLAB内存分配器创建eventitem
	if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))
		return -ENOMEM;

	// 初始化链表节点
	INIT_LIST_HEAD(&amp;epi-&gt;rdllink);
	INIT_LIST_HEAD(&amp;epi-&gt;fllink);
	INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);
	// 初始化基础属性
	epi-&gt;ep = ep;
	ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);
	epi-&gt;event = *event;
	epi-&gt;nwait = 0;
	epi-&gt;next = EP_UNACTIVE_PTR;

	// 初始化poll表，并注册回调函数ep_ptable_queue_proc
	epq.epi = epi;
	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);

	// 调用被插入文件的poll方法，最终会将当前epollitem放入到ready list并唤醒eventpoll中的等待进程
	revents = ep_item_poll(epi, &amp;epq.pt);

	/* Add the current item to the list of active epoll hook for this file */
	spin_lock(&amp;tfile-&gt;f_lock);
	// 将fllink加入到文件的f_ep_links列表中作为子项
	list_add_tail_rcu(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);
	spin_unlock(&amp;tfile-&gt;f_lock);

	// 将epollitem的rbn红黑树节点插入到eventpoll中的rbr红黑树中
	// 注意一点的是，节点的是根据epoll_filefd来比对的
	ep_rbtree_insert(ep, epi);

	spin_lock_irqsave(&amp;ep-&gt;lock, flags);

	if ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) {
		list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);
		ep_pm_stay_awake(epi);

		// 唤醒该队列
		if (waitqueue_active(&amp;ep-&gt;wq))
			wake_up_locked(&amp;ep-&gt;wq);
		if (waitqueue_active(&amp;ep-&gt;poll_wait))
			pwake++;
	}

	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);

	atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);

	// 唤醒并调用该队列中的事件
	if (pwake)
		ep_poll_safewake(&amp;ep-&gt;poll_wait);

	return 0;
...
}
```

epoll_ctl主要做了三个工作：

1. 创建并初始化eventitem
2. 为poll_wait函数初始化，当设备唤醒时会执行回调函数
3. 检查当前设备状态，如果已经就绪那么直接唤醒等待队列

### epoll_wait

```c
// epoll_wait(int epfd, epoll_event *events, int maxevents, int timeout)
SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events, int, maxevents, int, timeout)
{
	int error;
	struct fd f;
	struct eventpoll *ep;

	// 通过fd获取到文件信息
	f = fdget(epfd);

	// 通过private_data获取到eventpoll
	ep = f.file-&gt;private_data;

	// 调用ep_poll获取就绪的事件，并将它们派发到接收者的事件缓冲中
	error = ep_poll(ep, events, maxevents, timeout);

error_fput:
	fdput(f);
	return error;
}
```

epoll_wait的操作很简单，通过fd检索到相关eventpoll后马上调用核心函数`ep_poll`，这里详细分析一下：

```c
static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events, int maxevents, long timeout)
{
	int res = 0, eavail, timed_out = 0;
	unsigned long flags;
	long slack = 0;
	wait_queue_t wait;
	ktime_t expires, *to = NULL;

	if (timeout &gt; 0) {
		struct timespec end_time = ep_set_mstimeout(timeout);

		slack = select_estimate_accuracy(&amp;end_time);
		to = &amp;expires;
		*to = timespec_to_ktime(end_time);
	} else if (timeout == 0) {
		// 如果未设置超时事件，则直接获取事件，不进行阻塞
		timed_out = 1;
		spin_lock_irqsave(&amp;ep-&gt;lock, flags);
		goto check_events;
	}

fetch_events:
	spin_lock_irqsave(&amp;ep-&gt;lock, flags);

	if (!ep_events_available(ep)) {
		// 使用队列进行睡眠，直到ep_poll_callback被调用，队列被唤醒，才会接着执行下去
		init_waitqueue_entry(&amp;wait, current);
		__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);

		for (;;) {
			set_current_state(TASK_INTERRUPTIBLE);
			// 如果事件到来则退出循环
			if (ep_events_available(ep) || timed_out)
				break;
			if (signal_pending(current)) {
				res = -EINTR;
				break;
			}

			spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);
			if (!freezable_schedule_hrtimeout_range(to, slack,
								HRTIMER_MODE_ABS))
				timed_out = 1;

			spin_lock_irqsave(&amp;ep-&gt;lock, flags);
		}
		__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);

		set_current_state(TASK_RUNNING);
	}
check_events:
	// 是否存在入队的事件
	eavail = ep_events_available(ep);

	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);

	// 取出事件并发送到客户端进程
	if (!res &amp;&amp; eavail &amp;&amp;
	    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)
		goto fetch_events;

	return res;
}
```

ep_poll的主要操作在于从eventpoll中取出已经准备就绪的eventitem，随后调用`ep_send_events`，通过timeout参数判断是否需要阻塞以及需要阻塞的时间

```c
static int ep_send_events(struct eventpoll *ep,
			  struct epoll_event __user *events, int maxevents)
{
	struct ep_send_events_data esed;

	esed.maxevents = maxevents;
	esed.events = events;

	// ep_send_events_proc 为扫描回调函数
	return ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0, false);
}

static int ep_scan_ready_list(struct eventpoll *ep,
			      int (*sproc)(struct eventpoll *,
					   struct list_head *, void *),
			      void *priv, int depth, bool ep_locked)
{
	int error, pwake = 0;
	unsigned long flags;
	struct epitem *epi, *nepi;
	LIST_HEAD(txlist);
	...
	// 调用ep_send_events_proc进行回调
	error = (*sproc)(ep, &amp;txlist, priv);
	...
	return error;
}

static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head, void *priv)
{
	struct ep_send_events_data *esed = priv;
	int eventcnt;
	unsigned int revents;
	struct epitem *epi;
	struct epoll_event __user *uevent;
	struct wakeup_source *ws;
	poll_table pt;

	init_poll_funcptr(&amp;pt, NULL);
	for (eventcnt = 0, uevent = esed-&gt;events;
	     !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) {
	    // 从rdlink列表中获取到epollitem
		epi = list_first_entry(head, struct epitem, rdllink);
		
		ws = ep_wakeup_source(epi);
		if (ws) {
			if (ws-&gt;active)
				__pm_stay_awake(ep-&gt;ws);
			__pm_relax(ws);
		}

		list_del_init(&amp;epi-&gt;rdllink);

		// 从设备中读取事件
		revents = ep_item_poll(epi, &amp;pt);

		if (revents) {
			// 使用mmap将事件发送到客户端
			if (__put_user(revents, &amp;uevent-&gt;events) ||
			    __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) {
				list_add(&amp;epi-&gt;rdllink, head);
				ep_pm_stay_awake(epi);
				return eventcnt ? eventcnt : -EFAULT;
			}
			...
		}
	}

	return eventcnt;
}
```

### epoll中的生产者消费者模型

* 生产者: 由`epoll_ctl`最终调用的`ep_insert`触发，在驱动唤醒等待队列后会调用`ep_poll_callback`方法将epollitem添加到epollevent的`rdllist`中
* 消费者: 由`epoll_wait`最终调用的`ep_poll`触发，在等待队列响应后会继续执行，从`rdllist`中取出epoll_item，随后读取设备


"></textarea>
                <div class="markdown topic-body" data-enable-update-html=""  data-update-token="7NmSR1TU/FhLYtTPxTdccQ==" data-url="/topic/9423185607/update_html">
                  <div class="xzl-topic-content" id="xzl-topic-content">
                      <h2 id="简介">简介</h2>
<p>Handler这套线程异步通信框架在Android中的地位是不亚于Binder的，因为其基础设计简单、涉及的知识面广、业务使用场景多等原因，十分适合应用层的初中级的工程师进行深入学习</p>

<p>这篇文章中我将分析Handler核心功能的源码，分析将贯穿着framework, native和kernel的知识点：</p>

<ol>
<li>Handler发送异步消息原理</li>
<li>Looper派发消息原理</li>
<li>消息分割栏的原理与视图绘制的运用</li>
<li>epoll_create, epoll_ctl, epoll_wait三部曲的源码分析</li>
<li>epoll中生产者与消费者模型的运用</li>
</ol>

<p>同时按惯例，会在开篇给出总括全局的类图与架构图，方面阅读中定位理解与阅读后的回顾</p>
<h2 id="设计图">设计图</h2><h3 id="类图">类图</h3>
<p><img src="https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_class_diagram.jpg" title="" alt=""></p>

<ul>
<li>Message: 消息的抽象</li>
<li>Handler: 发送消息的工具类clo</li>
<li>MessageQueue: 主要维护了消息队列，同时也是与native通信的中枢</li>
<li>Looper: 循环获取消息并进行派发</li>
<li>Messenger: 可以跨进程传输的消息抽象</li>
</ul>
<h3 id="架构图">架构图</h3>
<p><img src="https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_arch.jpg" title="" alt=""></p>

<ol>
<li>一个APP中运行着多个线程，不同线程间可以互相拿到对方的Handler对象</li>
<li>MessageQueue和native直接通信，native中又和kernel通信，这样的调用链赋予了APP使用系统内核资源的能力</li>
<li>epoll机制在kernel中维护了一个链表与一颗红黑树是它效率优于poll与select的基础</li>
</ol>
<h2 id="发送跨线程异步消息: Handler.post()">发送跨线程异步消息: Handler.post()</h2>
<p>使用Handler的前提是获取到它的引用对象，然后才能够在对应的MessageQueue的消息队列插入消息。能够这样做的根本原因在于，线程之间的内存是可以相互访问的，这也是Handler能够实现跨线程通信的基本原理之一</p>

<p>下面从最常用的<code>Handler.post()</code>方法入手，看看消息发送的实现原理，这里需要说明的一点是，使用Handler发送消息的花样很多，但最终都需要调用到<code>MessageQueue.enqueueMessage()</code>方法来实现，这里就不一一介绍API的使用了</p>

<p>frameworks/base/core/java/android/os/Handler.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">post</span><span class="p">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span>  <span class="n">sendMessageDelayed</span><span class="o">(</span><span class="n">getPostMessage</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">postAtTime</span><span class="p">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">sendMessageAtTime</span><span class="o">(</span><span class="n">getPostMessage</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="n">uptimeMillis</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">sendMessageAtTime</span><span class="p">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这里获取到队列，队列是该线程唯一的，在Handler初始化时获取</span>
    <span class="n">MessageQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">mQueue</span><span class="o">;</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">enqueueMessage</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="n">uptimeMillis</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="p">(</span><span class="n">MessageQueue</span> <span class="n">queue</span><span class="o">,</span> <span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="c1">// 判断是否为异步消息，异步消息将不会受到分割栏的影响</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mAsynchronous</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">setAsynchronous</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 最终调用到MessageQueue去插入消息</span>
    <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueueMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">uptimeMillis</span><span class="o">);</span>
<span class="o">}</span></code></pre>

<p>可以看到Handler只是一个类似于工具的类，最终的消息管理方面的操作还是需要委托给MessageQueue去做</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="p">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这里会强制target成员的设置，分割栏的插入不是调用这个方法实现的</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"Message must have a target."</span><span class="o">);</span>

        <span class="c1">// 因为不同的线程都可以调用这个方法，所以使用类锁保证消息队列的异步安全</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">=</span> <span class="n">when</span><span class="o">;</span>
            <span class="n">Message</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">needWake</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">when</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
                <span class="n">needWake</span> <span class="o">=</span> <span class="n">mBlocked</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">needWake</span> <span class="o">=</span> <span class="n">mBlocked</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">();</span>
                <span class="n">Message</span> <span class="n">prev</span><span class="o">;</span>
                <span class="c1">// 遍历消息队列，插入到合适的位置</span>
                <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">needWake</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">needWake</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// invariant: p == prev.next</span>
                <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 调用到native尝试唤醒对端设备</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">needWake</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">nativeWake</span><span class="o">(</span><span class="n">mPtr</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>frameworks/base/core/jni/android_os_MessageQueue.cpp</p>
<pre class="highlight cpp"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">android_os_MessageQueue_nativeWake</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">,</span> <span class="n">jlong</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 通过ptr获取到NativeMessageQueue对象
</span>    <span class="n">NativeMessageQueue</span><span class="o">*</span> <span class="n">nativeMessageQueue</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">NativeMessageQueue</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">nativeMessageQueue</span><span class="o">-&gt;</span><span class="n">wake</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">NativeMessageQueue</span><span class="o">::</span><span class="n">wake</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 委托给native层的Looper进行处理
</span>    <span class="n">mLooper</span><span class="o">-&gt;</span><span class="n">wake</span><span class="p">();</span>
<span class="p">}</span></code></pre>

<p>system/core/libutils/Looper.cpp</p>
<pre class="highlight cpp"><code><span class="kt">void</span> <span class="n">Looper</span><span class="o">::</span><span class="n">wake</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 向文件描述符为mWakeEventFd设备写入，以此来唤醒监听设备的epoll
</span>    <span class="kt">ssize_t</span> <span class="n">nWrite</span> <span class="o">=</span> <span class="n">TEMP_FAILURE_RETRY</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">mWakeEventFd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)));</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>

<p>总结一下消息发送的主要工作：</p>

<ol>
<li>在java层的消息队列中根据时间插入消息</li>
<li>在native层，向对应的fd设备写入数据，以此来唤醒监听该设备的epoll</li>
</ol>
<h2 id="处理消息: Handler.handleMessage()">处理消息: Handler.handleMessage()</h2>
<p>handleMessage完全是处于被动调用的状态，每当消息到来时，会从kernel依次调用的native，再到java层的Looper</p>

<p>这里直接看Looper是如何获取到消息，并调用handleMessage的，省去了<code>Looper.prepare()</code>代码的分析</p>

<p>frameworks/base/core/java/android/os/Looper.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 从ThreadLocal中取出之前放入的Looper对象</span>
    <span class="kd">final</span> <span class="n">Looper</span> <span class="n">me</span> <span class="o">=</span> <span class="n">myLooper</span><span class="o">();</span>
    <span class="c1">// 获取到队列</span>
    <span class="kd">final</span> <span class="n">MessageQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="na">mQueue</span><span class="o">;</span>

    <span class="n">Binder</span><span class="o">.</span><span class="na">clearCallingIdentity</span><span class="o">();</span>
    <span class="kd">final</span> <span class="kt">long</span> <span class="n">ident</span> <span class="o">=</span> <span class="n">Binder</span><span class="o">.</span><span class="na">clearCallingIdentity</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="c1">// 获取下一个消息，这个方法在没有消息时会产生阻塞，只有在消息到来时才会触发</span>
        <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">next</span><span class="o">();</span> <span class="c1">// might block</span>

        <span class="o">...</span>

        <span class="c1">// 派发消息，最终会调用到Handler.handleMessage方法</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">dispatchMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">traceTag</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Trace</span><span class="o">.</span><span class="na">traceEnd</span><span class="o">(</span><span class="n">traceTag</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="o">...</span>

        <span class="c1">// 回收Message</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">recycleUnchecked</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>继续看看MessageQueue.next的实现：</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="n">Message</span> <span class="nf">next</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// mPtr实际上是NativeMesssageQueue的引用，方便在native层查询到MessageQueue</span>
    <span class="kd">final</span> <span class="kt">long</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">mPtr</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">pendingIdleHandlerCount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// -1 only during first iteration</span>
    <span class="kt">int</span> <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nextPollTimeoutMillis</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Binder</span><span class="o">.</span><span class="na">flushPendingCommands</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 调用native方法，之后调用到epoll_wait</span>
        <span class="n">nativePollOnce</span><span class="o">(</span><span class="n">ptr</span><span class="o">,</span> <span class="n">nextPollTimeoutMillis</span><span class="o">);</span>

        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">();</span>
            <span class="n">Message</span> <span class="n">prevMsg</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 消息分割栏，后面会做分析</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="n">prevMsg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 如果当前时间没有已经就绪的message，那么重置poll事件的时间</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">-</span> <span class="n">now</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Got a message.</span>
                    <span class="n">mBlocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">prevMsg</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">prevMsg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

                    <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
                    <span class="c1">// 如果该消息已经就绪，那么将它返回给Looper进行派发</span>
                    <span class="k">return</span> <span class="n">msg</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// No more messages.</span>
                <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 如果此次没有处理消息，则用来处理IdleHandler的操作，把优先级不高的操作放到这里去执行，尽量不浪费事件片</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pendingIdleHandlerCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">IdleHandler</span> <span class="n">idler</span> <span class="o">=</span> <span class="n">mPendingIdleHandlers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">mPendingIdleHandlers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// release the reference to the handler</span>

            <span class="kt">boolean</span> <span class="n">keep</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">idler</span><span class="o">.</span><span class="na">queueIdle</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Log</span><span class="o">.</span><span class="na">wtf</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"IdleHandler threw exception"</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(!</span><span class="n">keep</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">mIdleHandlers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">idler</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>核心操作<code>nativePollOnce</code>同样是在native层进行处理</p>

<p>frameworks/base/core/jni/android_os_MessageQueue.cpp</p>
<pre class="highlight cpp"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">android_os_MessageQueue_nativePollOnce</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jlong</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">jint</span> <span class="n">timeoutMillis</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NativeMessageQueue</span><span class="o">*</span> <span class="n">nativeMessageQueue</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">NativeMessageQueue</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">nativeMessageQueue</span><span class="o">-&gt;</span><span class="n">pollOnce</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">timeoutMillis</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">NativeMessageQueue</span><span class="o">::</span><span class="n">pollOnce</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">pollObj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeoutMillis</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mPollEnv</span> <span class="o">=</span> <span class="n">env</span><span class="p">;</span>
    <span class="n">mPollObj</span> <span class="o">=</span> <span class="n">pollObj</span><span class="p">;</span>
    <span class="c1">// 同样也是委托Looper进行处理
</span>    <span class="n">mLooper</span><span class="o">-&gt;</span><span class="n">pollOnce</span><span class="p">(</span><span class="n">timeoutMillis</span><span class="p">);</span>
    <span class="n">mPollObj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">mPollEnv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>system/core/libutils/Looper.cpp</p>
<pre class="highlight cpp"><code><span class="kt">int</span> <span class="n">Looper</span><span class="o">::</span><span class="n">pollOnce</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMillis</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">outFd</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">outEvents</span><span class="p">,</span> <span class="kt">void</span><span class="o">**</span> <span class="n">outData</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// 获取操作实际上是从reponse队列中拿取的
</span>        <span class="p">...</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outFd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">outFd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outEvents</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">outEvents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outData</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">outData</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 本质上在循环的调用pollInner方法，直到获取到了结果
</span>        <span class="n">result</span> <span class="o">=</span> <span class="n">pollInner</span><span class="p">(</span><span class="n">timeoutMillis</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Looper</span><span class="o">::</span><span class="n">pollInner</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMillis</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// Poll.
</span>    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">POLL_WAKE</span><span class="p">;</span>
    <span class="c1">// 清空response队列
</span>    <span class="n">mResponses</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">mResponseIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// We are about to idle.
</span>    <span class="n">mPolling</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="c1">// 初始化epoll_event
</span>    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">eventItems</span><span class="p">[</span><span class="n">EPOLL_MAX_EVENTS</span><span class="p">];</span>
    <span class="c1">// 使用epoll_wait调用的kernel去请求事件，kernel获取到事件后会通过mmap将epoll_event信息返回到native层
</span>    <span class="kt">int</span> <span class="n">eventCount</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">mEpollFd</span><span class="p">,</span> <span class="n">eventItems</span><span class="p">,</span> <span class="n">EPOLL_MAX_EVENTS</span><span class="p">,</span> <span class="n">timeoutMillis</span><span class="p">);</span>

    <span class="c1">// No longer idling.
</span>    <span class="n">mPolling</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// Acquire lock.
</span>    <span class="n">mLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="p">...</span>

    <span class="c1">// 获取到信息后，接下来就是读取了
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">eventCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventItems</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">epollEvents</span> <span class="o">=</span> <span class="n">eventItems</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="n">mWakeEventFd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">awoken</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">ssize_t</span> <span class="n">requestIndex</span> <span class="o">=</span> <span class="n">mRequests</span><span class="p">.</span><span class="n">indexOfKey</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">requestIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_INPUT</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_OUTPUT</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLERR</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_ERROR</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLHUP</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_HANGUP</span><span class="p">;</span>
                <span class="c1">// 插入到response队列中供后续获取
</span>                <span class="n">pushResponse</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">mRequests</span><span class="p">.</span><span class="n">valueAt</span><span class="p">(</span><span class="n">requestIndex</span><span class="p">));</span>
            <span class="p">}</span> 
        <span class="p">}</span>
    <span class="p">}</span>
<span class="n">Done</span><span class="o">:</span> <span class="p">;</span>

    <span class="n">mNextMessageUptime</span> <span class="o">=</span> <span class="n">LLONG_MAX</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">mMessageEnvelopes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nsecs_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">systemTime</span><span class="p">(</span><span class="n">SYSTEM_TIME_MONOTONIC</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">MessageEnvelope</span><span class="o">&amp;</span> <span class="n">messageEnvelope</span> <span class="o">=</span> <span class="n">mMessageEnvelopes</span><span class="p">.</span><span class="n">itemAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">messageEnvelope</span><span class="p">.</span><span class="n">uptime</span> <span class="o">&lt;=</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">{</span> <span class="c1">// obtain handler
</span>                <span class="n">sp</span><span class="o">&lt;</span><span class="n">MessageHandler</span><span class="o">&gt;</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">messageEnvelope</span><span class="p">.</span><span class="n">handler</span><span class="p">;</span>
                <span class="n">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageEnvelope</span><span class="p">.</span><span class="n">message</span><span class="p">;</span>
                <span class="n">mMessageEnvelopes</span><span class="p">.</span><span class="n">removeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="n">mSendingMessage</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">mLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
                <span class="c1">// 首先处理native层的Message
</span>                <span class="n">handler</span><span class="o">-&gt;</span><span class="n">handleMessage</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span> <span class="c1">// release handler
</span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Release lock.
</span>    <span class="n">mLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>native层<code>Looper.pollInner()</code>方法是获取Message的主要操作：</p>

<ol>
<li>调用epoll_wait在kernel中获取设备事件，该方法后续会做分析</li>
<li>获取到事件后进行解析并插入到response队列中</li>
<li>处理native事件</li>
</ol>

<p>可以看到，该方法会首先处理native层的Message，也就是说Handler这套框架对于native的消息是优先派发的</p>
<h2 id="设置同步分割栏: MessageQueue.postSyncBarrier()">设置同步分割栏: MessageQueue.postSyncBarrier()</h2>
<p>同步分割栏的原理其实很简单，本质上就是通过创建一个target成员为NULL的Message并插入到消息队列中，这样在这个特殊的Message之后的消息就不会被处理了，只有当这个Message被移除后才会继续执行之后的Message</p>

<p>最经典的实现就是ViewRootImpl调用<code>scheduleTraversals</code>方法进行视图更新时的使用:</p>

<p>frameworks/base/core/java/android/view/ViewRootImpl.java</p>
<pre class="highlight java"><code><span class="kt">void</span> <span class="nf">scheduleTraversals</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">mTraversalScheduled</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mTraversalScheduled</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 执行分割操作后会获取到分割令牌，使用它可以移除分割栏</span>
        <span class="n">mTraversalBarrier</span> <span class="o">=</span> <span class="n">mHandler</span><span class="o">.</span><span class="na">getLooper</span><span class="o">().</span><span class="na">getQueue</span><span class="o">().</span><span class="na">postSyncBarrier</span><span class="o">();</span>
        <span class="c1">// 发出一个有异步标志的Message，避免被分割</span>
        <span class="n">mChoreographer</span><span class="o">.</span><span class="na">postCallback</span><span class="o">(</span>
            <span class="n">Choreographer</span><span class="o">.</span><span class="na">CALLBACK_TRAVERSAL</span><span class="o">,</span> <span class="n">mTraversalRunnable</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>在执行<code>doTraversal</code>方法后，才会移出分割栏:</p>
<pre class="highlight java"><code><span class="kt">void</span> <span class="nf">doTraversal</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mTraversalScheduled</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mTraversalScheduled</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">mHandler</span><span class="o">.</span><span class="na">getLooper</span><span class="o">().</span><span class="na">getQueue</span><span class="o">().</span><span class="na">removeSyncBarrier</span><span class="o">(</span><span class="n">mTraversalBarrier</span><span class="o">);</span>

        <span class="n">performTraversals</span><span class="o">();</span>

        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>这样做的原因是，<code>doTraversal</code>的操作是通过Handler进行处理的，然而这个消息队列却是整个主线程公用的，比如说四大组件的各个生命周期的调用，然而<code>doTraversal</code>的内容是更新视图UI，这个任务无疑是最高优先级的。所以在这之前，需要确保队列中其它同步消息不会影响到它的执行</p>

<p>这里继续跟一下<code>MessageQueue.postSyncBarrier()</code>的实现:</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">postSyncBarrier</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">postSyncBarrier</span><span class="o">(</span><span class="n">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">postSyncBarrier</span><span class="p">(</span><span class="kt">long</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">token</span> <span class="o">=</span> <span class="n">mNextBarrierToken</span><span class="o">++;</span>
        <span class="kd">final</span> <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">=</span> <span class="n">when</span><span class="o">;</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">arg1</span> <span class="o">=</span> <span class="n">token</span><span class="o">;</span>
        <span class="c1">// 注意这里，并没有为target成员进行初始化</span>

        <span class="n">Message</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">Message</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
        <span class="c1">// 插入到队列中</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">when</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span> <span class="o">&lt;=</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// invariant: p == prev.next</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">token</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>可以看到，设置分割栏和普通的post Message是一样的，不同的是target是空的</p>

<p>下面接着来看看分割栏真正起作用的地方:</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="n">Message</span> <span class="nf">next</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="c1">// 进行队列遍历</span>
        <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">do</span> <span class="o">{</span>
                <span class="n">prevMsg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="c1">// 如果target为NULL，将会陷入这个循环，除非是有异步标志的消息才会跳出循环</span>
            <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
<h2 id="跨进程异步消息: Messenger">跨进程异步消息: Messenger</h2>
<p>Messenger是Android开发中算是比较冷门的一种跨进程通信方式，它的实现是依托着Binder+Handler这两种技术的配合，使得跨进程调用后服务端任务能够在指定的线程中被执行</p>

<p>这种方式其实就类似于ActivityThread的binder call接收后，使用指定Handler去post消息是一样的，不同的在于Messenger的对其进行了封装，使得开发者可以轻松的实现而不需要更多的代码</p>

<p>原生有个典型实现的MessengerService，可以参考它的思路：</p>

<p>frameworks/base/core/tests/coretests/src/android/os/MessengerService.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessengerService</span> <span class="kd">extends</span> <span class="n">Service</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Handler</span> <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="n">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Message</span> <span class="n">reply</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
            <span class="n">reply</span><span class="o">.</span><span class="na">copyFrom</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 这里的replyTo的mTarget实际上是对端的binder proxy，用以实现回调的功能</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">replyTo</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">reply</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="c1">// 创建一个Messenger，mTarget将会创建一个binder stub，服务方法运行在mHandler所在线程</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Messenger</span> <span class="n">mMessenger</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Messenger</span><span class="o">(</span><span class="n">mHandler</span><span class="o">);</span>

    <span class="kd">public</span> <span class="n">MessengerService</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">IBinder</span> <span class="n">onBind</span><span class="o">(</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 返回的是被创建的Messenger服务binder句柄</span>
        <span class="k">return</span> <span class="n">mMessenger</span><span class="o">.</span><span class="na">getBinder</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<ol>
<li>服务端可以通过继承MessengerService，定义自己的业务</li>
<li>客户端通过bind该service，可以获取Messenger的binder proxy句柄，从而实现通信。调用到服务端后，操作将会运行在mHandler所在线程</li>
<li>replyTo是客户端指定的，用来接受服务端的回复</li>
</ol>
<h2 id="实现基础: epoll">实现基础: epoll</h2>
<p>epoll和select和poll一样都是I/O多路复用技术，和它们不同的是，epoll只关心"活跃"的链接，不需要遍历全部的描述符集合，能够处理大量的链接请求</p>

<p>以下是一个使用epoll的典型代码示例，主要分为三部：</p>

<ol>
<li>使用epoll_create创建epoll的fd</li>
<li>使用epoll_ctl将需要监听的fd添加到epoll中</li>
<li>使用epoll_wait等待事件</li>
</ol>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">,</span> <span class="n">events</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">listen_sock</span><span class="p">,</span> <span class="n">conn_sock</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">epollfd</span><span class="p">;</span>

<span class="c1">// 创建epoll的文件描述符  
</span><span class="n">epollfd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epollfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_create1"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 将我们需要监听的文件描述符和事件通过epoll_ctl加入到epoll描述符中
</span><span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
<span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">listen_sock</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">listen_sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_ctl: listen_sock"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="c1">// 等待事件的发生
</span>    <span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_EVENTS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_wait"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 监听到事件，处理事件
</span>    <span class="p">...</span>
<span class="p">}</span></code></pre>

<p>epoll的实现很简单，简单到所有的主要逻辑都在单个文件中实现，文件路径在<code>kernel/msm-3.18/fs/eventpoll.c</code></p>

<p>下面接着分析epoll各个重要函数的源码</p>
<h3 id="epoll 初始化">epoll 初始化</h3>
<p>在使用epoll之前，系统需要在启动期间对epoll的基础设施进行初始化</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">eventpoll_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">si</span><span class="p">;</span>

    <span class="c1">// 获取系统内存状态
</span>    <span class="n">si_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">);</span>
    <span class="c1">// 根据系统内存配置设置单个用户可见监听的最大epoll个数
</span>    <span class="n">max_user_watches</span> <span class="o">=</span> <span class="p">(((</span><span class="n">si</span><span class="p">.</span><span class="n">totalram</span> <span class="o">-</span> <span class="n">si</span><span class="p">.</span><span class="n">totalhigh</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">/</span> <span class="n">EP_ITEM_COST</span><span class="p">;</span>

    <span class="c1">// 初始化调用队列，方便检查是否超过最大嵌套次数
</span>    <span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_loop_ncalls</span><span class="p">);</span>
    <span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_safewake_ncalls</span><span class="p">);</span>
    <span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_readywalk_ncalls</span><span class="p">);</span>

    <span class="c1">// 创建用于分配epitem数据结构的的SLAB缓存
</span>    <span class="n">epi_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">"eventpoll_epi"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epitem</span><span class="p">),</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 创建用于分配eppoll_entry数据结构的SLAB缓存
</span>    <span class="n">pwq_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">"eventpoll_pwq"</span><span class="p">,</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eppoll_entry</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 在系统启动过程中，init进程设备初始化时对epoll进行初始化
</span><span class="n">fs_initcall</span><span class="p">(</span><span class="n">eventpoll_init</span><span class="p">);</span></code></pre>

<p>epoll 初始化期间主要完成的三个工作:</p>

<ol>
<li>根据内存配置，初始化单个用户最大可见听epoll个数</li>
<li>初始化调用队列，以此来判断嵌套调用是超过上限</li>
<li>初始化SLAB内存缓存，以此来提升epoll使用内存的效率</li>
</ol>
<h3 id="epoll_create">epoll_create</h3>
<p>在native Looper.cpp的实现中，epoll_create的调用函数用以创建一个epoll，但是在内核源码中并没有直接发现epoll_create之类的函数</p>

<p>查阅资料后发现，内核将epoll系列的函数都使用了SYSCALL_DEFINE宏调用来实现了，SYSCALL_DEFINE后的数字x代表了该函数拥有x个参数，之所以使用这种方式来声明函数是为了修复64位Linux系统上的CVE-2009-2009漏洞</p>
<pre class="highlight c"><code><span class="c1">// 为了阅读源码的便捷性，可以直接将该宏调用看成 epoll_create(int flags);
</span><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">epoll_create1</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

    <span class="c1">// 初始化eventpoll结构
</span>    <span class="n">error</span> <span class="o">=</span> <span class="n">ep_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="p">);</span>
    <span class="c1">// 获取一个没有使用过的fd
</span>    <span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">));</span>

    <span class="c1">// 创建eventpoll文件，file_operations为eventpoll_fops
</span>    <span class="c1">// 同时将ep设置到file-&gt;private_data中
</span>    <span class="n">file</span> <span class="o">=</span> <span class="n">anon_inode_getfile</span><span class="p">(</span><span class="s">"[eventpoll]"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventpoll_fops</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
                 <span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">));</span>

    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
    <span class="c1">// 将fd与文件进行关联
</span>    <span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>

<span class="n">out_free_fd</span><span class="o">:</span>
    <span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="n">out_free_ep</span><span class="o">:</span>
    <span class="n">ep_free</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>epoll_create的主要做了两个工作：</p>

<ol>
<li>新建并初始化一个epollpoll结构</li>
<li>创建eventpoll文件、获取一个空闲fd，并将两者进行关联</li>
</ol>
<h3 id="epoll_ctl">epoll_ctl</h3><pre class="highlight c"><code><span class="c1">// epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</span><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_ctl</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">full_check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fd</span> <span class="n">f</span><span class="p">,</span> <span class="n">tf</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">epds</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">tep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ep_op_has_event</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="c1">// 将epoll_event信息使用mmap从native拷贝到kernel
</span>        <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)))</span>
        <span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

    <span class="c1">// 获取mEpollFd, mWakeEventFd对应文件
</span>    <span class="n">f</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
    <span class="n">tf</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="c1">// 从文件的private_data中获取到eventpoll
</span>    <span class="n">ep</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

    <span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">// 通过file, fd在eventpoll的红黑树中进行查询，看是否存在已经保存的eventitem
</span>    <span class="n">epi</span> <span class="o">=</span> <span class="n">ep_find</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="c1">// 进行op操作分流
</span>    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果未查询到，则创建并插入新的eventitem
</span>            <span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">full_check</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span>
            <span class="c1">// 如果查询到，则移除该eventitem
</span>            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_remove</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果查询到，则进行替换
</span>            <span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_modify</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

<span class="n">error_tgt_fput</span><span class="o">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">full_check</span><span class="p">)</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>

    <span class="n">fdput</span><span class="p">(</span><span class="n">tf</span><span class="p">);</span>
<span class="n">error_fput</span><span class="o">:</span>
    <span class="n">fdput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="n">error_return</span><span class="o">:</span>

    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>epoll_ctl主要做了两个工作：</p>

<ol>
<li>将epoll_event信息使用mmap拷贝到内核中</li>
<li>通过fd获取到对应的file文件，并通过private_data获取到eventpoll</li>
<li>通过file,fd在eventpoll中进行查询，看是否存在对应的eventitem</li>
<li>根据查询到的eventitem进行对应的操作</li>
</ol>

<p>这里详细分析下<code>ep_insert</code>方法:</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
             <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full_check</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">revents</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">user_watches</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ep_pqueue</span> <span class="n">epq</span><span class="p">;</span>

    <span class="c1">// 使用SLAB内存分配器创建eventitem
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="c1">// 初始化链表节点
</span>    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
    <span class="c1">// 初始化基础属性
</span>    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
    <span class="n">ep_set_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>

    <span class="c1">// 初始化poll表，并注册回调函数ep_ptable_queue_proc
</span>    <span class="n">epq</span><span class="p">.</span><span class="n">epi</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
    <span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">ep_ptable_queue_proc</span><span class="p">);</span>

    <span class="c1">// 调用被插入文件的poll方法，最终会将当前epollitem放入到ready list并唤醒eventpoll中的等待进程
</span>    <span class="n">revents</span> <span class="o">=</span> <span class="n">ep_item_poll</span><span class="p">(</span><span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">);</span>

    <span class="cm">/* Add the current item to the list of active epoll hook for this file */</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
    <span class="c1">// 将fllink加入到文件的f_ep_links列表中作为子项
</span>    <span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_ep_links</span><span class="p">);</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

    <span class="c1">// 将epollitem的rbn红黑树节点插入到eventpoll中的rbr红黑树中
</span>    <span class="c1">// 注意一点的是，节点的是根据epoll_filefd来比对的
</span>    <span class="n">ep_rbtree_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>

    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
        <span class="n">ep_pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>

        <span class="c1">// 唤醒该队列
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
            <span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
            <span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">epoll_watches</span><span class="p">);</span>

    <span class="c1">// 唤醒并调用该队列中的事件
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
        <span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span></code></pre>

<p>epoll_ctl主要做了三个工作：</p>

<ol>
<li>创建并初始化eventitem</li>
<li>为poll_wait函数初始化，当设备唤醒时会执行回调函数</li>
<li>检查当前设备状态，如果已经就绪那么直接唤醒等待队列</li>
</ol>
<h3 id="epoll_wait">epoll_wait</h3><pre class="highlight c"><code><span class="c1">// epoll_wait(int epfd, epoll_event *events, int maxevents, int timeout)
</span><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_wait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fd</span> <span class="n">f</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

    <span class="c1">// 通过fd获取到文件信息
</span>    <span class="n">f</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>

    <span class="c1">// 通过private_data获取到eventpoll
</span>    <span class="n">ep</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

    <span class="c1">// 调用ep_poll获取就绪的事件，并将它们派发到接收者的事件缓冲中
</span>    <span class="n">error</span> <span class="o">=</span> <span class="n">ep_poll</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

<span class="n">error_fput</span><span class="o">:</span>
    <span class="n">fdput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>epoll_wait的操作很简单，通过fd检索到相关eventpoll后马上调用核心函数<code>ep_poll</code>，这里详细分析一下：</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eavail</span><span class="p">,</span> <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">slack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
    <span class="n">ktime_t</span> <span class="n">expires</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">timespec</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">ep_set_mstimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>

        <span class="n">slack</span> <span class="o">=</span> <span class="n">select_estimate_accuracy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_time</span><span class="p">);</span>
        <span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">;</span>
        <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">end_time</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果未设置超时事件，则直接获取事件，不进行阻塞
</span>        <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">check_events</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">fetch_events:</span>
    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 使用队列进行睡眠，直到ep_poll_callback被调用，队列被唤醒，才会接着执行下去
</span>        <span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
        <span class="n">__add_wait_queue_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
            <span class="c1">// 如果事件到来则退出循环
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">||</span> <span class="n">timed_out</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">freezable_schedule_hrtimeout_range</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">slack</span><span class="p">,</span>
                                <span class="n">HRTIMER_MODE_ABS</span><span class="p">))</span>
                <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

        <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">check_events:</span>
    <span class="c1">// 是否存在入队的事件
</span>    <span class="n">eavail</span> <span class="o">=</span> <span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="c1">// 取出事件并发送到客户端进程
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">eavail</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="p">(</span><span class="n">res</span> <span class="o">=</span> <span class="n">ep_send_events</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timed_out</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">fetch_events</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>ep_poll的主要操作在于从eventpoll中取出已经准备就绪的eventitem，随后调用<code>ep_send_events</code>，通过timeout参数判断是否需要阻塞以及需要阻塞的时间</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_send_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
              <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="n">esed</span><span class="p">;</span>

    <span class="n">esed</span><span class="p">.</span><span class="n">maxevents</span> <span class="o">=</span> <span class="n">maxevents</span><span class="p">;</span>
    <span class="n">esed</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">;</span>

    <span class="c1">// ep_send_events_proc 为扫描回调函数
</span>    <span class="k">return</span> <span class="n">ep_scan_ready_list</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep_send_events_proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">esed</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_scan_ready_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="p">,</span>
                       <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
                  <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ep_locked</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">,</span> <span class="o">*</span><span class="n">nepi</span><span class="p">;</span>
    <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">txlist</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">// 调用ep_send_events_proc进行回调
</span>    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txlist</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_send_events_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="o">*</span><span class="n">esed</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">eventcnt</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uevent</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wakeup_source</span> <span class="o">*</span><span class="n">ws</span><span class="p">;</span>
    <span class="n">poll_table</span> <span class="n">pt</span><span class="p">;</span>

    <span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">eventcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uevent</span> <span class="o">=</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">;</span>
         <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">eventcnt</span> <span class="o">&lt;</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">maxevents</span><span class="p">;)</span> <span class="p">{</span>
        <span class="c1">// 从rdlink列表中获取到epollitem
</span>        <span class="n">epi</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rdllink</span><span class="p">);</span>

        <span class="n">ws</span> <span class="o">=</span> <span class="n">ep_wakeup_source</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ws</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ws</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
                <span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
            <span class="n">__pm_relax</span><span class="p">(</span><span class="n">ws</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>

        <span class="c1">// 从设备中读取事件
</span>        <span class="n">revents</span> <span class="o">=</span> <span class="n">ep_item_poll</span><span class="p">(</span><span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">revents</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 使用mmap将事件发送到客户端
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">revents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">||</span>
                <span class="n">__put_user</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
                <span class="n">ep_pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">eventcnt</span> <span class="o">?</span> <span class="n">eventcnt</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">eventcnt</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h3 id="epoll中的生产者消费者模型">epoll中的生产者消费者模型</h3>
<ul>
<li>生产者: 由<code>epoll_ctl</code>最终调用的<code>ep_insert</code>触发，在驱动唤醒等待队列后会调用<code>ep_poll_callback</code>方法将epollitem添加到epollevent的<code>rdllist</code>中</li>
<li>消费者: 由<code>epoll_wait</code>最终调用的<code>ep_poll</code>触发，在等待队列响应后会继续执行，从<code>rdllist</code>中取出epoll_item，随后读取设备</li>
</ul>
                  </div>
                    <div class="xzl-topic-body-content hidden_topic_body hidden" id="xzl-topic-body-content">
                        <h2 id="简介">简介</h2>
<p>Handler这套线程异步通信框架在Android中的地位是不亚于Binder的，因为其基础设计简单、涉及的知识面广、业务使用场景多等原因，十分适合应用层的初中级的工程师进行深入学习</p>

<p>这篇文章中我将分析Handler核心功能的源码，分析将贯穿着framework, native和kernel的知识点：</p>

<ol>
<li>Handler发送异步消息原理</li>
<li>Looper派发消息原理</li>
<li>消息分割栏的原理与视图绘制的运用</li>
<li>epoll_create, epoll_ctl, epoll_wait三部曲的源码分析</li>
<li>epoll中生产者与消费者模型的运用</li>
</ol>

<p>同时按惯例，会在开篇给出总括全局的类图与架构图，方面阅读中定位理解与阅读后的回顾</p>
<h2 id="设计图">设计图</h2><h3 id="类图">类图</h3>
<p><img src="https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_class_diagram.jpg" title="" alt=""></p>

<ul>
<li>Message: 消息的抽象</li>
<li>Handler: 发送消息的工具类clo</li>
<li>MessageQueue: 主要维护了消息队列，同时也是与native通信的中枢</li>
<li>Looper: 循环获取消息并进行派发</li>
<li>Messenger: 可以跨进程传输的消息抽象</li>
</ul>
<h3 id="架构图">架构图</h3>
<p><img src="https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_arch.jpg" title="" alt=""></p>

<ol>
<li>一个APP中运行着多个线程，不同线程间可以互相拿到对方的Handler对象</li>
<li>MessageQueue和native直接通信，native中又和kernel通信，这样的调用链赋予了APP使用系统内核资源的能力</li>
<li>epoll机制在kernel中维护了一个链表与一颗红黑树是它效率优于poll与select的基础</li>
</ol>
<h2 id="发送跨线程异步消息: Handler.post()">发送跨线程异步消息: Handler.post()</h2>
<p>使用Handler的前提是获取到它的引用对象，然后才能够在对应的MessageQueue的消息队列插入消息。能够这样做的根本原因在于，线程之间的内存是可以相互访问的，这也是Handler能够实现跨线程通信的基本原理之一</p>

<p>下面从最常用的<code>Handler.post()</code>方法入手，看看消息发送的实现原理，这里需要说明的一点是，使用Handler发送消息的花样很多，但最终都需要调用到<code>MessageQueue.enqueueMessage()</code>方法来实现，这里就不一一介绍API的使用了</p>

<p>frameworks/base/core/java/android/os/Handler.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">post</span><span class="p">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span>  <span class="n">sendMessageDelayed</span><span class="o">(</span><span class="n">getPostMessage</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">postAtTime</span><span class="p">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">sendMessageAtTime</span><span class="o">(</span><span class="n">getPostMessage</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="n">uptimeMillis</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">sendMessageAtTime</span><span class="p">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这里获取到队列，队列是该线程唯一的，在Handler初始化时获取</span>
    <span class="n">MessageQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">mQueue</span><span class="o">;</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">enqueueMessage</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="n">uptimeMillis</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="p">(</span><span class="n">MessageQueue</span> <span class="n">queue</span><span class="o">,</span> <span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="c1">// 判断是否为异步消息，异步消息将不会受到分割栏的影响</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mAsynchronous</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">setAsynchronous</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 最终调用到MessageQueue去插入消息</span>
    <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueueMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">uptimeMillis</span><span class="o">);</span>
<span class="o">}</span></code></pre>

<p>可以看到Handler只是一个类似于工具的类，最终的消息管理方面的操作还是需要委托给MessageQueue去做</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="p">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这里会强制target成员的设置，分割栏的插入不是调用这个方法实现的</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"Message must have a target."</span><span class="o">);</span>

        <span class="c1">// 因为不同的线程都可以调用这个方法，所以使用类锁保证消息队列的异步安全</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">=</span> <span class="n">when</span><span class="o">;</span>
            <span class="n">Message</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">needWake</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">when</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
                <span class="n">needWake</span> <span class="o">=</span> <span class="n">mBlocked</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">needWake</span> <span class="o">=</span> <span class="n">mBlocked</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">();</span>
                <span class="n">Message</span> <span class="n">prev</span><span class="o">;</span>
                <span class="c1">// 遍历消息队列，插入到合适的位置</span>
                <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">needWake</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">needWake</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// invariant: p == prev.next</span>
                <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 调用到native尝试唤醒对端设备</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">needWake</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">nativeWake</span><span class="o">(</span><span class="n">mPtr</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>frameworks/base/core/jni/android_os_MessageQueue.cpp</p>
<pre class="highlight cpp"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">android_os_MessageQueue_nativeWake</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">,</span> <span class="n">jlong</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 通过ptr获取到NativeMessageQueue对象
</span>    <span class="n">NativeMessageQueue</span><span class="o">*</span> <span class="n">nativeMessageQueue</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">NativeMessageQueue</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">nativeMessageQueue</span><span class="o">-&gt;</span><span class="n">wake</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">NativeMessageQueue</span><span class="o">::</span><span class="n">wake</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 委托给native层的Looper进行处理
</span>    <span class="n">mLooper</span><span class="o">-&gt;</span><span class="n">wake</span><span class="p">();</span>
<span class="p">}</span></code></pre>

<p>system/core/libutils/Looper.cpp</p>
<pre class="highlight cpp"><code><span class="kt">void</span> <span class="n">Looper</span><span class="o">::</span><span class="n">wake</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 向文件描述符为mWakeEventFd设备写入，以此来唤醒监听设备的epoll
</span>    <span class="kt">ssize_t</span> <span class="n">nWrite</span> <span class="o">=</span> <span class="n">TEMP_FAILURE_RETRY</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">mWakeEventFd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)));</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>

<p>总结一下消息发送的主要工作：</p>

<ol>
<li>在java层的消息队列中根据时间插入消息</li>
<li>在native层，向对应的fd设备写入数据，以此来唤醒监听该设备的epoll</li>
</ol>
<h2 id="处理消息: Handler.handleMessage()">处理消息: Handler.handleMessage()</h2>
<p>handleMessage完全是处于被动调用的状态，每当消息到来时，会从kernel依次调用的native，再到java层的Looper</p>

<p>这里直接看Looper是如何获取到消息，并调用handleMessage的，省去了<code>Looper.prepare()</code>代码的分析</p>

<p>frameworks/base/core/java/android/os/Looper.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 从ThreadLocal中取出之前放入的Looper对象</span>
    <span class="kd">final</span> <span class="n">Looper</span> <span class="n">me</span> <span class="o">=</span> <span class="n">myLooper</span><span class="o">();</span>
    <span class="c1">// 获取到队列</span>
    <span class="kd">final</span> <span class="n">MessageQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="na">mQueue</span><span class="o">;</span>

    <span class="n">Binder</span><span class="o">.</span><span class="na">clearCallingIdentity</span><span class="o">();</span>
    <span class="kd">final</span> <span class="kt">long</span> <span class="n">ident</span> <span class="o">=</span> <span class="n">Binder</span><span class="o">.</span><span class="na">clearCallingIdentity</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="c1">// 获取下一个消息，这个方法在没有消息时会产生阻塞，只有在消息到来时才会触发</span>
        <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">next</span><span class="o">();</span> <span class="c1">// might block</span>

        <span class="o">...</span>

        <span class="c1">// 派发消息，最终会调用到Handler.handleMessage方法</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">dispatchMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">traceTag</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Trace</span><span class="o">.</span><span class="na">traceEnd</span><span class="o">(</span><span class="n">traceTag</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="o">...</span>

        <span class="c1">// 回收Message</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">recycleUnchecked</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>继续看看MessageQueue.next的实现：</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="n">Message</span> <span class="nf">next</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// mPtr实际上是NativeMesssageQueue的引用，方便在native层查询到MessageQueue</span>
    <span class="kd">final</span> <span class="kt">long</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">mPtr</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">pendingIdleHandlerCount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// -1 only during first iteration</span>
    <span class="kt">int</span> <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nextPollTimeoutMillis</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Binder</span><span class="o">.</span><span class="na">flushPendingCommands</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 调用native方法，之后调用到epoll_wait</span>
        <span class="n">nativePollOnce</span><span class="o">(</span><span class="n">ptr</span><span class="o">,</span> <span class="n">nextPollTimeoutMillis</span><span class="o">);</span>

        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">();</span>
            <span class="n">Message</span> <span class="n">prevMsg</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 消息分割栏，后面会做分析</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="n">prevMsg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 如果当前时间没有已经就绪的message，那么重置poll事件的时间</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">-</span> <span class="n">now</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Got a message.</span>
                    <span class="n">mBlocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">prevMsg</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">prevMsg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

                    <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
                    <span class="c1">// 如果该消息已经就绪，那么将它返回给Looper进行派发</span>
                    <span class="k">return</span> <span class="n">msg</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// No more messages.</span>
                <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 如果此次没有处理消息，则用来处理IdleHandler的操作，把优先级不高的操作放到这里去执行，尽量不浪费事件片</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pendingIdleHandlerCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">IdleHandler</span> <span class="n">idler</span> <span class="o">=</span> <span class="n">mPendingIdleHandlers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">mPendingIdleHandlers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// release the reference to the handler</span>

            <span class="kt">boolean</span> <span class="n">keep</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">idler</span><span class="o">.</span><span class="na">queueIdle</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Log</span><span class="o">.</span><span class="na">wtf</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"IdleHandler threw exception"</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(!</span><span class="n">keep</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">mIdleHandlers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">idler</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>核心操作<code>nativePollOnce</code>同样是在native层进行处理</p>

<p>frameworks/base/core/jni/android_os_MessageQueue.cpp</p>
<pre class="highlight cpp"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">android_os_MessageQueue_nativePollOnce</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jlong</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">jint</span> <span class="n">timeoutMillis</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NativeMessageQueue</span><span class="o">*</span> <span class="n">nativeMessageQueue</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">NativeMessageQueue</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">nativeMessageQueue</span><span class="o">-&gt;</span><span class="n">pollOnce</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">timeoutMillis</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">NativeMessageQueue</span><span class="o">::</span><span class="n">pollOnce</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">pollObj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeoutMillis</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mPollEnv</span> <span class="o">=</span> <span class="n">env</span><span class="p">;</span>
    <span class="n">mPollObj</span> <span class="o">=</span> <span class="n">pollObj</span><span class="p">;</span>
    <span class="c1">// 同样也是委托Looper进行处理
</span>    <span class="n">mLooper</span><span class="o">-&gt;</span><span class="n">pollOnce</span><span class="p">(</span><span class="n">timeoutMillis</span><span class="p">);</span>
    <span class="n">mPollObj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">mPollEnv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>system/core/libutils/Looper.cpp</p>
<pre class="highlight cpp"><code><span class="kt">int</span> <span class="n">Looper</span><span class="o">::</span><span class="n">pollOnce</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMillis</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">outFd</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">outEvents</span><span class="p">,</span> <span class="kt">void</span><span class="o">**</span> <span class="n">outData</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// 获取操作实际上是从reponse队列中拿取的
</span>        <span class="p">...</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outFd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">outFd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outEvents</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">outEvents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outData</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">outData</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 本质上在循环的调用pollInner方法，直到获取到了结果
</span>        <span class="n">result</span> <span class="o">=</span> <span class="n">pollInner</span><span class="p">(</span><span class="n">timeoutMillis</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Looper</span><span class="o">::</span><span class="n">pollInner</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMillis</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// Poll.
</span>    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">POLL_WAKE</span><span class="p">;</span>
    <span class="c1">// 清空response队列
</span>    <span class="n">mResponses</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">mResponseIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// We are about to idle.
</span>    <span class="n">mPolling</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="c1">// 初始化epoll_event
</span>    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">eventItems</span><span class="p">[</span><span class="n">EPOLL_MAX_EVENTS</span><span class="p">];</span>
    <span class="c1">// 使用epoll_wait调用的kernel去请求事件，kernel获取到事件后会通过mmap将epoll_event信息返回到native层
</span>    <span class="kt">int</span> <span class="n">eventCount</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">mEpollFd</span><span class="p">,</span> <span class="n">eventItems</span><span class="p">,</span> <span class="n">EPOLL_MAX_EVENTS</span><span class="p">,</span> <span class="n">timeoutMillis</span><span class="p">);</span>

    <span class="c1">// No longer idling.
</span>    <span class="n">mPolling</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// Acquire lock.
</span>    <span class="n">mLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="p">...</span>

    <span class="c1">// 获取到信息后，接下来就是读取了
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">eventCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventItems</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">epollEvents</span> <span class="o">=</span> <span class="n">eventItems</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="n">mWakeEventFd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">awoken</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">ssize_t</span> <span class="n">requestIndex</span> <span class="o">=</span> <span class="n">mRequests</span><span class="p">.</span><span class="n">indexOfKey</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">requestIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_INPUT</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_OUTPUT</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLERR</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_ERROR</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLHUP</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_HANGUP</span><span class="p">;</span>
                <span class="c1">// 插入到response队列中供后续获取
</span>                <span class="n">pushResponse</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">mRequests</span><span class="p">.</span><span class="n">valueAt</span><span class="p">(</span><span class="n">requestIndex</span><span class="p">));</span>
            <span class="p">}</span> 
        <span class="p">}</span>
    <span class="p">}</span>
<span class="n">Done</span><span class="o">:</span> <span class="p">;</span>

    <span class="n">mNextMessageUptime</span> <span class="o">=</span> <span class="n">LLONG_MAX</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">mMessageEnvelopes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nsecs_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">systemTime</span><span class="p">(</span><span class="n">SYSTEM_TIME_MONOTONIC</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">MessageEnvelope</span><span class="o">&amp;</span> <span class="n">messageEnvelope</span> <span class="o">=</span> <span class="n">mMessageEnvelopes</span><span class="p">.</span><span class="n">itemAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">messageEnvelope</span><span class="p">.</span><span class="n">uptime</span> <span class="o">&lt;=</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">{</span> <span class="c1">// obtain handler
</span>                <span class="n">sp</span><span class="o">&lt;</span><span class="n">MessageHandler</span><span class="o">&gt;</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">messageEnvelope</span><span class="p">.</span><span class="n">handler</span><span class="p">;</span>
                <span class="n">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageEnvelope</span><span class="p">.</span><span class="n">message</span><span class="p">;</span>
                <span class="n">mMessageEnvelopes</span><span class="p">.</span><span class="n">removeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="n">mSendingMessage</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">mLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
                <span class="c1">// 首先处理native层的Message
</span>                <span class="n">handler</span><span class="o">-&gt;</span><span class="n">handleMessage</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span> <span class="c1">// release handler
</span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Release lock.
</span>    <span class="n">mLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>native层<code>Looper.pollInner()</code>方法是获取Message的主要操作：</p>

<ol>
<li>调用epoll_wait在kernel中获取设备事件，该方法后续会做分析</li>
<li>获取到事件后进行解析并插入到response队列中</li>
<li>处理native事件</li>
</ol>

<p>可以看到，该方法会首先处理native层的Message，也就是说Handler这套框架对于native的消息是优先派发的</p>
<h2 id="设置同步分割栏: MessageQueue.postSyncBarrier()">设置同步分割栏: MessageQueue.postSyncBarrier()</h2>
<p>同步分割栏的原理其实很简单，本质上就是通过创建一个target成员为NULL的Message并插入到消息队列中，这样在这个特殊的Message之后的消息就不会被处理了，只有当这个Message被移除后才会继续执行之后的Message</p>

<p>最经典的实现就是ViewRootImpl调用<code>scheduleTraversals</code>方法进行视图更新时的使用:</p>

<p>frameworks/base/core/java/android/view/ViewRootImpl.java</p>
<pre class="highlight java"><code><span class="kt">void</span> <span class="nf">scheduleTraversals</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">mTraversalScheduled</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mTraversalScheduled</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 执行分割操作后会获取到分割令牌，使用它可以移除分割栏</span>
        <span class="n">mTraversalBarrier</span> <span class="o">=</span> <span class="n">mHandler</span><span class="o">.</span><span class="na">getLooper</span><span class="o">().</span><span class="na">getQueue</span><span class="o">().</span><span class="na">postSyncBarrier</span><span class="o">();</span>
        <span class="c1">// 发出一个有异步标志的Message，避免被分割</span>
        <span class="n">mChoreographer</span><span class="o">.</span><span class="na">postCallback</span><span class="o">(</span>
            <span class="n">Choreographer</span><span class="o">.</span><span class="na">CALLBACK_TRAVERSAL</span><span class="o">,</span> <span class="n">mTraversalRunnable</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>在执行<code>doTraversal</code>方法后，才会移出分割栏:</p>
<pre class="highlight java"><code><span class="kt">void</span> <span class="nf">doTraversal</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mTraversalScheduled</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mTraversalScheduled</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">mHandler</span><span class="o">.</span><span class="na">getLooper</span><span class="o">().</span><span class="na">getQueue</span><span class="o">().</span><span class="na">removeSyncBarrier</span><span class="o">(</span><span class="n">mTraversalBarrier</span><span class="o">);</span>

        <span class="n">performTraversals</span><span class="o">();</span>

        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>这样做的原因是，<code>doTraversal</code>的操作是通过Handler进行处理的，然而这个消息队列却是整个主线程公用的，比如说四大组件的各个生命周期的调用，然而<code>doTraversal</code>的内容是更新视图UI，这个任务无疑是最高优先级的。所以在这之前，需要确保队列中其它同步消息不会影响到它的执行</p>

<p>这里继续跟一下<code>MessageQueue.postSyncBarrier()</code>的实现:</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">postSyncBarrier</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">postSyncBarrier</span><span class="o">(</span><span class="n">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">postSyncBarrier</span><span class="p">(</span><span class="kt">long</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">token</span> <span class="o">=</span> <span class="n">mNextBarrierToken</span><span class="o">++;</span>
        <span class="kd">final</span> <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">=</span> <span class="n">when</span><span class="o">;</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">arg1</span> <span class="o">=</span> <span class="n">token</span><span class="o">;</span>
        <span class="c1">// 注意这里，并没有为target成员进行初始化</span>

        <span class="n">Message</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">Message</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
        <span class="c1">// 插入到队列中</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">when</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span> <span class="o">&lt;=</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// invariant: p == prev.next</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">token</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>可以看到，设置分割栏和普通的post Message是一样的，不同的是target是空的</p>

<p>下面接着来看看分割栏真正起作用的地方:</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="n">Message</span> <span class="nf">next</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="c1">// 进行队列遍历</span>
        <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">do</span> <span class="o">{</span>
                <span class="n">prevMsg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="c1">// 如果target为NULL，将会陷入这个循环，除非是有异步标志的消息才会跳出循环</span>
            <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
<h2 id="跨进程异步消息: Messenger">跨进程异步消息: Messenger</h2>
<p>Messenger是Android开发中算是比较冷门的一种跨进程通信方式，它的实现是依托着Binder+Handler这两种技术的配合，使得跨进程调用后服务端任务能够在指定的线程中被执行</p>

<p>这种方式其实就类似于ActivityThread的binder call接收后，使用指定Handler去post消息是一样的，不同的在于Messenger的对其进行了封装，使得开发者可以轻松的实现而不需要更多的代码</p>

<p>原生有个典型实现的MessengerService，可以参考它的思路：</p>

<p>frameworks/base/core/tests/coretests/src/android/os/MessengerService.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessengerService</span> <span class="kd">extends</span> <span class="n">Service</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Handler</span> <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="n">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Message</span> <span class="n">reply</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
            <span class="n">reply</span><span class="o">.</span><span class="na">copyFrom</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 这里的replyTo的mTarget实际上是对端的binder proxy，用以实现回调的功能</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">replyTo</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">reply</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="c1">// 创建一个Messenger，mTarget将会创建一个binder stub，服务方法运行在mHandler所在线程</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Messenger</span> <span class="n">mMessenger</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Messenger</span><span class="o">(</span><span class="n">mHandler</span><span class="o">);</span>

    <span class="kd">public</span> <span class="n">MessengerService</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">IBinder</span> <span class="n">onBind</span><span class="o">(</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 返回的是被创建的Messenger服务binder句柄</span>
        <span class="k">return</span> <span class="n">mMessenger</span><span class="o">.</span><span class="na">getBinder</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<ol>
<li>服务端可以通过继承MessengerService，定义自己的业务</li>
<li>客户端通过bind该service，可以获取Messenger的binder proxy句柄，从而实现通信。调用到服务端后，操作将会运行在mHandler所在线程</li>
<li>replyTo是客户端指定的，用来接受服务端的回复</li>
</ol>
<h2 id="实现基础: epoll">实现基础: epoll</h2>
<p>epoll和select和poll一样都是I/O多路复用技术，和它们不同的是，epoll只关心"活跃"的链接，不需要遍历全部的描述符集合，能够处理大量的链接请求</p>

<p>以下是一个使用epoll的典型代码示例，主要分为三部：</p>

<ol>
<li>使用epoll_create创建epoll的fd</li>
<li>使用epoll_ctl将需要监听的fd添加到epoll中</li>
<li>使用epoll_wait等待事件</li>
</ol>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">,</span> <span class="n">events</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">listen_sock</span><span class="p">,</span> <span class="n">conn_sock</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">epollfd</span><span class="p">;</span>

<span class="c1">// 创建epoll的文件描述符  
</span><span class="n">epollfd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epollfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_create1"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 将我们需要监听的文件描述符和事件通过epoll_ctl加入到epoll描述符中
</span><span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
<span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">listen_sock</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">listen_sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_ctl: listen_sock"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="c1">// 等待事件的发生
</span>    <span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_EVENTS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_wait"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 监听到事件，处理事件
</span>    <span class="p">...</span>
<span class="p">}</span></code></pre>

<p>epoll的实现很简单，简单到所有的主要逻辑都在单个文件中实现，文件路径在<code>kernel/msm-3.18/fs/eventpoll.c</code></p>

<p>下面接着分析epoll各个重要函数的源码</p>
<h3 id="epoll 初始化">epoll 初始化</h3>
<p>在使用epoll之前，系统需要在启动期间对epoll的基础设施进行初始化</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">eventpoll_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">si</span><span class="p">;</span>

    <span class="c1">// 获取系统内存状态
</span>    <span class="n">si_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">);</span>
    <span class="c1">// 根据系统内存配置设置单个用户可见监听的最大epoll个数
</span>    <span class="n">max_user_watches</span> <span class="o">=</span> <span class="p">(((</span><span class="n">si</span><span class="p">.</span><span class="n">totalram</span> <span class="o">-</span> <span class="n">si</span><span class="p">.</span><span class="n">totalhigh</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">/</span> <span class="n">EP_ITEM_COST</span><span class="p">;</span>

    <span class="c1">// 初始化调用队列，方便检查是否超过最大嵌套次数
</span>    <span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_loop_ncalls</span><span class="p">);</span>
    <span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_safewake_ncalls</span><span class="p">);</span>
    <span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_readywalk_ncalls</span><span class="p">);</span>

    <span class="c1">// 创建用于分配epitem数据结构的的SLAB缓存
</span>    <span class="n">epi_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">"eventpoll_epi"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epitem</span><span class="p">),</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 创建用于分配eppoll_entry数据结构的SLAB缓存
</span>    <span class="n">pwq_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">"eventpoll_pwq"</span><span class="p">,</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eppoll_entry</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 在系统启动过程中，init进程设备初始化时对epoll进行初始化
</span><span class="n">fs_initcall</span><span class="p">(</span><span class="n">eventpoll_init</span><span class="p">);</span></code></pre>

<p>epoll 初始化期间主要完成的三个工作:</p>

<ol>
<li>根据内存配置，初始化单个用户最大可见听epoll个数</li>
<li>初始化调用队列，以此来判断嵌套调用是超过上限</li>
<li>初始化SLAB内存缓存，以此来提升epoll使用内存的效率</li>
</ol>
<h3 id="epoll_create">epoll_create</h3>
<p>在native Looper.cpp的实现中，epoll_create的调用函数用以创建一个epoll，但是在内核源码中并没有直接发现epoll_create之类的函数</p>

<p>查阅资料后发现，内核将epoll系列的函数都使用了SYSCALL_DEFINE宏调用来实现了，SYSCALL_DEFINE后的数字x代表了该函数拥有x个参数，之所以使用这种方式来声明函数是为了修复64位Linux系统上的CVE-2009-2009漏洞</p>
<pre class="highlight c"><code><span class="c1">// 为了阅读源码的便捷性，可以直接将该宏调用看成 epoll_create(int flags);
</span><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">epoll_create1</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

    <span class="c1">// 初始化eventpoll结构
</span>    <span class="n">error</span> <span class="o">=</span> <span class="n">ep_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="p">);</span>
    <span class="c1">// 获取一个没有使用过的fd
</span>    <span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">));</span>

    <span class="c1">// 创建eventpoll文件，file_operations为eventpoll_fops
</span>    <span class="c1">// 同时将ep设置到file-&gt;private_data中
</span>    <span class="n">file</span> <span class="o">=</span> <span class="n">anon_inode_getfile</span><span class="p">(</span><span class="s">"[eventpoll]"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventpoll_fops</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
                 <span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">));</span>

    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
    <span class="c1">// 将fd与文件进行关联
</span>    <span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>

<span class="n">out_free_fd</span><span class="o">:</span>
    <span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="n">out_free_ep</span><span class="o">:</span>
    <span class="n">ep_free</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>epoll_create的主要做了两个工作：</p>

<ol>
<li>新建并初始化一个epollpoll结构</li>
<li>创建eventpoll文件、获取一个空闲fd，并将两者进行关联</li>
</ol>
<h3 id="epoll_ctl">epoll_ctl</h3><pre class="highlight c"><code><span class="c1">// epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</span><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_ctl</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">full_check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fd</span> <span class="n">f</span><span class="p">,</span> <span class="n">tf</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">epds</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">tep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ep_op_has_event</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="c1">// 将epoll_event信息使用mmap从native拷贝到kernel
</span>        <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)))</span>
        <span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

    <span class="c1">// 获取mEpollFd, mWakeEventFd对应文件
</span>    <span class="n">f</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
    <span class="n">tf</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="c1">// 从文件的private_data中获取到eventpoll
</span>    <span class="n">ep</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

    <span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">// 通过file, fd在eventpoll的红黑树中进行查询，看是否存在已经保存的eventitem
</span>    <span class="n">epi</span> <span class="o">=</span> <span class="n">ep_find</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="c1">// 进行op操作分流
</span>    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果未查询到，则创建并插入新的eventitem
</span>            <span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">full_check</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span>
            <span class="c1">// 如果查询到，则移除该eventitem
</span>            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_remove</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果查询到，则进行替换
</span>            <span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_modify</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

<span class="n">error_tgt_fput</span><span class="o">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">full_check</span><span class="p">)</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>

    <span class="n">fdput</span><span class="p">(</span><span class="n">tf</span><span class="p">);</span>
<span class="n">error_fput</span><span class="o">:</span>
    <span class="n">fdput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="n">error_return</span><span class="o">:</span>

    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>epoll_ctl主要做了两个工作：</p>

<ol>
<li>将epoll_event信息使用mmap拷贝到内核中</li>
<li>通过fd获取到对应的file文件，并通过private_data获取到eventpoll</li>
<li>通过file,fd在eventpoll中进行查询，看是否存在对应的eventitem</li>
<li>根据查询到的eventitem进行对应的操作</li>
</ol>

<p>这里详细分析下<code>ep_insert</code>方法:</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
             <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full_check</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">revents</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">user_watches</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ep_pqueue</span> <span class="n">epq</span><span class="p">;</span>

    <span class="c1">// 使用SLAB内存分配器创建eventitem
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="c1">// 初始化链表节点
</span>    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
    <span class="c1">// 初始化基础属性
</span>    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
    <span class="n">ep_set_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>

    <span class="c1">// 初始化poll表，并注册回调函数ep_ptable_queue_proc
</span>    <span class="n">epq</span><span class="p">.</span><span class="n">epi</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
    <span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">ep_ptable_queue_proc</span><span class="p">);</span>

    <span class="c1">// 调用被插入文件的poll方法，最终会将当前epollitem放入到ready list并唤醒eventpoll中的等待进程
</span>    <span class="n">revents</span> <span class="o">=</span> <span class="n">ep_item_poll</span><span class="p">(</span><span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">);</span>

    <span class="cm">/* Add the current item to the list of active epoll hook for this file */</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
    <span class="c1">// 将fllink加入到文件的f_ep_links列表中作为子项
</span>    <span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_ep_links</span><span class="p">);</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

    <span class="c1">// 将epollitem的rbn红黑树节点插入到eventpoll中的rbr红黑树中
</span>    <span class="c1">// 注意一点的是，节点的是根据epoll_filefd来比对的
</span>    <span class="n">ep_rbtree_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>

    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
        <span class="n">ep_pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>

        <span class="c1">// 唤醒该队列
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
            <span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
            <span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">epoll_watches</span><span class="p">);</span>

    <span class="c1">// 唤醒并调用该队列中的事件
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
        <span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span></code></pre>

<p>epoll_ctl主要做了三个工作：</p>

<ol>
<li>创建并初始化eventitem</li>
<li>为poll_wait函数初始化，当设备唤醒时会执行回调函数</li>
<li>检查当前设备状态，如果已经就绪那么直接唤醒等待队列</li>
</ol>
<h3 id="epoll_wait">epoll_wait</h3><pre class="highlight c"><code><span class="c1">// epoll_wait(int epfd, epoll_event *events, int maxevents, int timeout)
</span><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_wait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fd</span> <span class="n">f</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

    <span class="c1">// 通过fd获取到文件信息
</span>    <span class="n">f</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>

    <span class="c1">// 通过private_data获取到eventpoll
</span>    <span class="n">ep</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

    <span class="c1">// 调用ep_poll获取就绪的事件，并将它们派发到接收者的事件缓冲中
</span>    <span class="n">error</span> <span class="o">=</span> <span class="n">ep_poll</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

<span class="n">error_fput</span><span class="o">:</span>
    <span class="n">fdput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>epoll_wait的操作很简单，通过fd检索到相关eventpoll后马上调用核心函数<code>ep_poll</code>，这里详细分析一下：</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eavail</span><span class="p">,</span> <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">slack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
    <span class="n">ktime_t</span> <span class="n">expires</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">timespec</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">ep_set_mstimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>

        <span class="n">slack</span> <span class="o">=</span> <span class="n">select_estimate_accuracy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_time</span><span class="p">);</span>
        <span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">;</span>
        <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">end_time</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果未设置超时事件，则直接获取事件，不进行阻塞
</span>        <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">check_events</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">fetch_events:</span>
    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 使用队列进行睡眠，直到ep_poll_callback被调用，队列被唤醒，才会接着执行下去
</span>        <span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
        <span class="n">__add_wait_queue_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
            <span class="c1">// 如果事件到来则退出循环
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">||</span> <span class="n">timed_out</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">freezable_schedule_hrtimeout_range</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">slack</span><span class="p">,</span>
                                <span class="n">HRTIMER_MODE_ABS</span><span class="p">))</span>
                <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

        <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">check_events:</span>
    <span class="c1">// 是否存在入队的事件
</span>    <span class="n">eavail</span> <span class="o">=</span> <span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="c1">// 取出事件并发送到客户端进程
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">eavail</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="p">(</span><span class="n">res</span> <span class="o">=</span> <span class="n">ep_send_events</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timed_out</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">fetch_events</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>ep_poll的主要操作在于从eventpoll中取出已经准备就绪的eventitem，随后调用<code>ep_send_events</code>，通过timeout参数判断是否需要阻塞以及需要阻塞的时间</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_send_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
              <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="n">esed</span><span class="p">;</span>

    <span class="n">esed</span><span class="p">.</span><span class="n">maxevents</span> <span class="o">=</span> <span class="n">maxevents</span><span class="p">;</span>
    <span class="n">esed</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">;</span>

    <span class="c1">// ep_send_events_proc 为扫描回调函数
</span>    <span class="k">return</span> <span class="n">ep_scan_ready_list</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep_send_events_proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">esed</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_scan_ready_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="p">,</span>
                       <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
                  <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ep_locked</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">,</span> <span class="o">*</span><span class="n">nepi</span><span class="p">;</span>
    <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">txlist</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">// 调用ep_send_events_proc进行回调
</span>    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txlist</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_send_events_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="o">*</span><span class="n">esed</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">eventcnt</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uevent</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wakeup_source</span> <span class="o">*</span><span class="n">ws</span><span class="p">;</span>
    <span class="n">poll_table</span> <span class="n">pt</span><span class="p">;</span>

    <span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">eventcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uevent</span> <span class="o">=</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">;</span>
         <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">eventcnt</span> <span class="o">&lt;</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">maxevents</span><span class="p">;)</span> <span class="p">{</span>
        <span class="c1">// 从rdlink列表中获取到epollitem
</span>        <span class="n">epi</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rdllink</span><span class="p">);</span>

        <span class="n">ws</span> <span class="o">=</span> <span class="n">ep_wakeup_source</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ws</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ws</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
                <span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
            <span class="n">__pm_relax</span><span class="p">(</span><span class="n">ws</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>

        <span class="c1">// 从设备中读取事件
</span>        <span class="n">revents</span> <span class="o">=</span> <span class="n">ep_item_poll</span><span class="p">(</span><span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">revents</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 使用mmap将事件发送到客户端
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">revents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">||</span>
                <span class="n">__put_user</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
                <span class="n">ep_pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">eventcnt</span> <span class="o">?</span> <span class="n">eventcnt</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">eventcnt</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h3 id="epoll中的生产者消费者模型">epoll中的生产者消费者模型</h3>
<ul>
<li>生产者: 由<code>epoll_ctl</code>最终调用的<code>ep_insert</code>触发，在驱动唤醒等待队列后会调用<code>ep_poll_callback</code>方法将epollitem添加到epollevent的<code>rdllist</code>中</li>
<li>消费者: 由<code>epoll_wait</code>最终调用的<code>ep_poll</code>触发，在等待队列响应后会继续执行，从<code>rdllist</code>中取出epoll_item，随后读取设备</li>
</ul>
                    </div>
                    <div class="xzl-topic-summary-content hidden_topic_body hidden" id="xzl-topic-summary-content">
                        <h2 id="简介">简介</h2>
<p>Handler这套线程异步通信框架在Android中的地位是不亚于Binder的，因为其基础设计简单、涉及的知识面广、业务使用场景多等原因，十分适合应用层的初中级的工程师进行深入学习</p>

<p>这篇文章中我将分析Handler核心功能的源码，分析将贯穿着framework, native和kernel的知识点：</p>

<ol>
<li>Handler发送异步消息原理</li>
<li>Looper派发消息原理</li>
<li>消息分割栏的原理与视图绘制的运用</li>
<li>epoll_create, epoll_ctl, epoll_wait三部曲的源码分析</li>
<li>epoll中生产者与消费者模型的运用</li>
</ol>

<p>同时按惯例，会在开篇给出总括全局的类图与架构图，方面阅读中定位理解与阅读后的回顾</p>
<h2 id="设计图">设计图</h2><h3 id="类图">类图</h3>
<p><img src="https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_class_diagram.jpg" title="" alt=""></p>

<ul>
<li>Message: 消息的抽象</li>
<li>Handler: 发送消息的工具类clo</li>
<li>MessageQueue: 主要维护了消息队列，同时也是与native通信的中枢</li>
<li>Looper: 循环获取消息并进行派发</li>
<li>Messenger: 可以跨进程传输的消息抽象</li>
</ul>
<h3 id="架构图">架构图</h3>
<p><img src="https://raw.githubusercontent.com/RickAi/Images/master/blog/handler_arch.jpg" title="" alt=""></p>

<ol>
<li>一个APP中运行着多个线程，不同线程间可以互相拿到对方的Handler对象</li>
<li>MessageQueue和native直接通信，native中又和kernel通信，这样的调用链赋予了APP使用系统内核资源的能力</li>
<li>epoll机制在kernel中维护了一个链表与一颗红黑树是它效率优于poll与select的基础</li>
</ol>
<h2 id="发送跨线程异步消息: Handler.post()">发送跨线程异步消息: Handler.post()</h2>
<p>使用Handler的前提是获取到它的引用对象，然后才能够在对应的MessageQueue的消息队列插入消息。能够这样做的根本原因在于，线程之间的内存是可以相互访问的，这也是Handler能够实现跨线程通信的基本原理之一</p>

<p>下面从最常用的<code>Handler.post()</code>方法入手，看看消息发送的实现原理，这里需要说明的一点是，使用Handler发送消息的花样很多，但最终都需要调用到<code>MessageQueue.enqueueMessage()</code>方法来实现，这里就不一一介绍API的使用了</p>

<p>frameworks/base/core/java/android/os/Handler.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">post</span><span class="p">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span>  <span class="n">sendMessageDelayed</span><span class="o">(</span><span class="n">getPostMessage</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">postAtTime</span><span class="p">(</span><span class="n">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">sendMessageAtTime</span><span class="o">(</span><span class="n">getPostMessage</span><span class="o">(</span><span class="n">r</span><span class="o">),</span> <span class="n">uptimeMillis</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">sendMessageAtTime</span><span class="p">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这里获取到队列，队列是该线程唯一的，在Handler初始化时获取</span>
    <span class="n">MessageQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">mQueue</span><span class="o">;</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">enqueueMessage</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="n">msg</span><span class="o">,</span> <span class="n">uptimeMillis</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="p">(</span><span class="n">MessageQueue</span> <span class="n">queue</span><span class="o">,</span> <span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">uptimeMillis</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
    <span class="c1">// 判断是否为异步消息，异步消息将不会受到分割栏的影响</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mAsynchronous</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">setAsynchronous</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 最终调用到MessageQueue去插入消息</span>
    <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueueMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">uptimeMillis</span><span class="o">);</span>
<span class="o">}</span></code></pre>

<p>可以看到Handler只是一个类似于工具的类，最终的消息管理方面的操作还是需要委托给MessageQueue去做</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="kt">boolean</span> <span class="nf">enqueueMessage</span><span class="p">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">,</span> <span class="kt">long</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这里会强制target成员的设置，分割栏的插入不是调用这个方法实现的</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">"Message must have a target."</span><span class="o">);</span>

        <span class="c1">// 因为不同的线程都可以调用这个方法，所以使用类锁保证消息队列的异步安全</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">=</span> <span class="n">when</span><span class="o">;</span>
            <span class="n">Message</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">needWake</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">when</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
                <span class="n">needWake</span> <span class="o">=</span> <span class="n">mBlocked</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">needWake</span> <span class="o">=</span> <span class="n">mBlocked</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">();</span>
                <span class="n">Message</span> <span class="n">prev</span><span class="o">;</span>
                <span class="c1">// 遍历消息队列，插入到合适的位置</span>
                <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">when</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">needWake</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">needWake</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// invariant: p == prev.next</span>
                <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 调用到native尝试唤醒对端设备</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">needWake</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">nativeWake</span><span class="o">(</span><span class="n">mPtr</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>frameworks/base/core/jni/android_os_MessageQueue.cpp</p>
<pre class="highlight cpp"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">android_os_MessageQueue_nativeWake</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jclass</span> <span class="n">clazz</span><span class="p">,</span> <span class="n">jlong</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 通过ptr获取到NativeMessageQueue对象
</span>    <span class="n">NativeMessageQueue</span><span class="o">*</span> <span class="n">nativeMessageQueue</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">NativeMessageQueue</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">nativeMessageQueue</span><span class="o">-&gt;</span><span class="n">wake</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">NativeMessageQueue</span><span class="o">::</span><span class="n">wake</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 委托给native层的Looper进行处理
</span>    <span class="n">mLooper</span><span class="o">-&gt;</span><span class="n">wake</span><span class="p">();</span>
<span class="p">}</span></code></pre>

<p>system/core/libutils/Looper.cpp</p>
<pre class="highlight cpp"><code><span class="kt">void</span> <span class="n">Looper</span><span class="o">::</span><span class="n">wake</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">inc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 向文件描述符为mWakeEventFd设备写入，以此来唤醒监听设备的epoll
</span>    <span class="kt">ssize_t</span> <span class="n">nWrite</span> <span class="o">=</span> <span class="n">TEMP_FAILURE_RETRY</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">mWakeEventFd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)));</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>

<p>总结一下消息发送的主要工作：</p>

<ol>
<li>在java层的消息队列中根据时间插入消息</li>
<li>在native层，向对应的fd设备写入数据，以此来唤醒监听该设备的epoll</li>
</ol>
<h2 id="处理消息: Handler.handleMessage()">处理消息: Handler.handleMessage()</h2>
<p>handleMessage完全是处于被动调用的状态，每当消息到来时，会从kernel依次调用的native，再到java层的Looper</p>

<p>这里直接看Looper是如何获取到消息，并调用handleMessage的，省去了<code>Looper.prepare()</code>代码的分析</p>

<p>frameworks/base/core/java/android/os/Looper.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">loop</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 从ThreadLocal中取出之前放入的Looper对象</span>
    <span class="kd">final</span> <span class="n">Looper</span> <span class="n">me</span> <span class="o">=</span> <span class="n">myLooper</span><span class="o">();</span>
    <span class="c1">// 获取到队列</span>
    <span class="kd">final</span> <span class="n">MessageQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">me</span><span class="o">.</span><span class="na">mQueue</span><span class="o">;</span>

    <span class="n">Binder</span><span class="o">.</span><span class="na">clearCallingIdentity</span><span class="o">();</span>
    <span class="kd">final</span> <span class="kt">long</span> <span class="n">ident</span> <span class="o">=</span> <span class="n">Binder</span><span class="o">.</span><span class="na">clearCallingIdentity</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="c1">// 获取下一个消息，这个方法在没有消息时会产生阻塞，只有在消息到来时才会触发</span>
        <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">next</span><span class="o">();</span> <span class="c1">// might block</span>

        <span class="o">...</span>

        <span class="c1">// 派发消息，最终会调用到Handler.handleMessage方法</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">dispatchMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">traceTag</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Trace</span><span class="o">.</span><span class="na">traceEnd</span><span class="o">(</span><span class="n">traceTag</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="o">...</span>

        <span class="c1">// 回收Message</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">recycleUnchecked</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>继续看看MessageQueue.next的实现：</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="n">Message</span> <span class="nf">next</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// mPtr实际上是NativeMesssageQueue的引用，方便在native层查询到MessageQueue</span>
    <span class="kd">final</span> <span class="kt">long</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">mPtr</span><span class="o">;</span>

    <span class="kt">int</span> <span class="n">pendingIdleHandlerCount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// -1 only during first iteration</span>
    <span class="kt">int</span> <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nextPollTimeoutMillis</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Binder</span><span class="o">.</span><span class="na">flushPendingCommands</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 调用native方法，之后调用到epoll_wait</span>
        <span class="n">nativePollOnce</span><span class="o">(</span><span class="n">ptr</span><span class="o">,</span> <span class="n">nextPollTimeoutMillis</span><span class="o">);</span>

        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">();</span>
            <span class="n">Message</span> <span class="n">prevMsg</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 消息分割栏，后面会做分析</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="n">prevMsg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 如果当前时间没有已经就绪的message，那么重置poll事件的时间</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="o">.</span><span class="na">when</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">-</span> <span class="n">now</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Got a message.</span>
                    <span class="n">mBlocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">prevMsg</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">prevMsg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

                    <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
                    <span class="c1">// 如果该消息已经就绪，那么将它返回给Looper进行派发</span>
                    <span class="k">return</span> <span class="n">msg</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// No more messages.</span>
                <span class="n">nextPollTimeoutMillis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 如果此次没有处理消息，则用来处理IdleHandler的操作，把优先级不高的操作放到这里去执行，尽量不浪费事件片</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pendingIdleHandlerCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">IdleHandler</span> <span class="n">idler</span> <span class="o">=</span> <span class="n">mPendingIdleHandlers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">mPendingIdleHandlers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// release the reference to the handler</span>

            <span class="kt">boolean</span> <span class="n">keep</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">idler</span><span class="o">.</span><span class="na">queueIdle</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Log</span><span class="o">.</span><span class="na">wtf</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"IdleHandler threw exception"</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(!</span><span class="n">keep</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">mIdleHandlers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">idler</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>核心操作<code>nativePollOnce</code>同样是在native层进行处理</p>

<p>frameworks/base/core/jni/android_os_MessageQueue.cpp</p>
<pre class="highlight cpp"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">android_os_MessageQueue_nativePollOnce</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jlong</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">jint</span> <span class="n">timeoutMillis</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NativeMessageQueue</span><span class="o">*</span> <span class="n">nativeMessageQueue</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">NativeMessageQueue</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">nativeMessageQueue</span><span class="o">-&gt;</span><span class="n">pollOnce</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">timeoutMillis</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">NativeMessageQueue</span><span class="o">::</span><span class="n">pollOnce</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">pollObj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeoutMillis</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mPollEnv</span> <span class="o">=</span> <span class="n">env</span><span class="p">;</span>
    <span class="n">mPollObj</span> <span class="o">=</span> <span class="n">pollObj</span><span class="p">;</span>
    <span class="c1">// 同样也是委托Looper进行处理
</span>    <span class="n">mLooper</span><span class="o">-&gt;</span><span class="n">pollOnce</span><span class="p">(</span><span class="n">timeoutMillis</span><span class="p">);</span>
    <span class="n">mPollObj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">mPollEnv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>system/core/libutils/Looper.cpp</p>
<pre class="highlight cpp"><code><span class="kt">int</span> <span class="n">Looper</span><span class="o">::</span><span class="n">pollOnce</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMillis</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">outFd</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">outEvents</span><span class="p">,</span> <span class="kt">void</span><span class="o">**</span> <span class="n">outData</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// 获取操作实际上是从reponse队列中拿取的
</span>        <span class="p">...</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outFd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">outFd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outEvents</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">outEvents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outData</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">outData</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 本质上在循环的调用pollInner方法，直到获取到了结果
</span>        <span class="n">result</span> <span class="o">=</span> <span class="n">pollInner</span><span class="p">(</span><span class="n">timeoutMillis</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Looper</span><span class="o">::</span><span class="n">pollInner</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeoutMillis</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// Poll.
</span>    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">POLL_WAKE</span><span class="p">;</span>
    <span class="c1">// 清空response队列
</span>    <span class="n">mResponses</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">mResponseIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// We are about to idle.
</span>    <span class="n">mPolling</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="c1">// 初始化epoll_event
</span>    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">eventItems</span><span class="p">[</span><span class="n">EPOLL_MAX_EVENTS</span><span class="p">];</span>
    <span class="c1">// 使用epoll_wait调用的kernel去请求事件，kernel获取到事件后会通过mmap将epoll_event信息返回到native层
</span>    <span class="kt">int</span> <span class="n">eventCount</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">mEpollFd</span><span class="p">,</span> <span class="n">eventItems</span><span class="p">,</span> <span class="n">EPOLL_MAX_EVENTS</span><span class="p">,</span> <span class="n">timeoutMillis</span><span class="p">);</span>

    <span class="c1">// No longer idling.
</span>    <span class="n">mPolling</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// Acquire lock.
</span>    <span class="n">mLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="p">...</span>

    <span class="c1">// 获取到信息后，接下来就是读取了
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">eventCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventItems</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">epollEvents</span> <span class="o">=</span> <span class="n">eventItems</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="n">mWakeEventFd</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">awoken</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">ssize_t</span> <span class="n">requestIndex</span> <span class="o">=</span> <span class="n">mRequests</span><span class="p">.</span><span class="n">indexOfKey</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">requestIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_INPUT</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_OUTPUT</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLERR</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_ERROR</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">epollEvents</span> <span class="o">&amp;</span> <span class="n">EPOLLHUP</span><span class="p">)</span> <span class="n">events</span> <span class="o">|=</span> <span class="n">EVENT_HANGUP</span><span class="p">;</span>
                <span class="c1">// 插入到response队列中供后续获取
</span>                <span class="n">pushResponse</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">mRequests</span><span class="p">.</span><span class="n">valueAt</span><span class="p">(</span><span class="n">requestIndex</span><span class="p">));</span>
            <span class="p">}</span> 
        <span class="p">}</span>
    <span class="p">}</span>
<span class="n">Done</span><span class="o">:</span> <span class="p">;</span>

    <span class="n">mNextMessageUptime</span> <span class="o">=</span> <span class="n">LLONG_MAX</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">mMessageEnvelopes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nsecs_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">systemTime</span><span class="p">(</span><span class="n">SYSTEM_TIME_MONOTONIC</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">MessageEnvelope</span><span class="o">&amp;</span> <span class="n">messageEnvelope</span> <span class="o">=</span> <span class="n">mMessageEnvelopes</span><span class="p">.</span><span class="n">itemAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">messageEnvelope</span><span class="p">.</span><span class="n">uptime</span> <span class="o">&lt;=</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">{</span> <span class="c1">// obtain handler
</span>                <span class="n">sp</span><span class="o">&lt;</span><span class="n">MessageHandler</span><span class="o">&gt;</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">messageEnvelope</span><span class="p">.</span><span class="n">handler</span><span class="p">;</span>
                <span class="n">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="n">messageEnvelope</span><span class="p">.</span><span class="n">message</span><span class="p">;</span>
                <span class="n">mMessageEnvelopes</span><span class="p">.</span><span class="n">removeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="n">mSendingMessage</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">mLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
                <span class="c1">// 首先处理native层的Message
</span>                <span class="n">handler</span><span class="o">-&gt;</span><span class="n">handleMessage</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
            <span class="p">}</span> <span class="c1">// release handler
</span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Release lock.
</span>    <span class="n">mLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>native层<code>Looper.pollInner()</code>方法是获取Message的主要操作：</p>

<ol>
<li>调用epoll_wait在kernel中获取设备事件，该方法后续会做分析</li>
<li>获取到事件后进行解析并插入到response队列中</li>
<li>处理native事件</li>
</ol>

<p>可以看到，该方法会首先处理native层的Message，也就是说Handler这套框架对于native的消息是优先派发的</p>
<h2 id="设置同步分割栏: MessageQueue.postSyncBarrier()">设置同步分割栏: MessageQueue.postSyncBarrier()</h2>
<p>同步分割栏的原理其实很简单，本质上就是通过创建一个target成员为NULL的Message并插入到消息队列中，这样在这个特殊的Message之后的消息就不会被处理了，只有当这个Message被移除后才会继续执行之后的Message</p>

<p>最经典的实现就是ViewRootImpl调用<code>scheduleTraversals</code>方法进行视图更新时的使用:</p>

<p>frameworks/base/core/java/android/view/ViewRootImpl.java</p>
<pre class="highlight java"><code><span class="kt">void</span> <span class="nf">scheduleTraversals</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">mTraversalScheduled</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mTraversalScheduled</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 执行分割操作后会获取到分割令牌，使用它可以移除分割栏</span>
        <span class="n">mTraversalBarrier</span> <span class="o">=</span> <span class="n">mHandler</span><span class="o">.</span><span class="na">getLooper</span><span class="o">().</span><span class="na">getQueue</span><span class="o">().</span><span class="na">postSyncBarrier</span><span class="o">();</span>
        <span class="c1">// 发出一个有异步标志的Message，避免被分割</span>
        <span class="n">mChoreographer</span><span class="o">.</span><span class="na">postCallback</span><span class="o">(</span>
            <span class="n">Choreographer</span><span class="o">.</span><span class="na">CALLBACK_TRAVERSAL</span><span class="o">,</span> <span class="n">mTraversalRunnable</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>在执行<code>doTraversal</code>方法后，才会移出分割栏:</p>
<pre class="highlight java"><code><span class="kt">void</span> <span class="nf">doTraversal</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mTraversalScheduled</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mTraversalScheduled</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">mHandler</span><span class="o">.</span><span class="na">getLooper</span><span class="o">().</span><span class="na">getQueue</span><span class="o">().</span><span class="na">removeSyncBarrier</span><span class="o">(</span><span class="n">mTraversalBarrier</span><span class="o">);</span>

        <span class="n">performTraversals</span><span class="o">();</span>

        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>这样做的原因是，<code>doTraversal</code>的操作是通过Handler进行处理的，然而这个消息队列却是整个主线程公用的，比如说四大组件的各个生命周期的调用，然而<code>doTraversal</code>的内容是更新视图UI，这个任务无疑是最高优先级的。所以在这之前，需要确保队列中其它同步消息不会影响到它的执行</p>

<p>这里继续跟一下<code>MessageQueue.postSyncBarrier()</code>的实现:</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">postSyncBarrier</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">postSyncBarrier</span><span class="o">(</span><span class="n">SystemClock</span><span class="o">.</span><span class="na">uptimeMillis</span><span class="o">());</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">int</span> <span class="nf">postSyncBarrier</span><span class="p">(</span><span class="kt">long</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">token</span> <span class="o">=</span> <span class="n">mNextBarrierToken</span><span class="o">++;</span>
        <span class="kd">final</span> <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">markInUse</span><span class="o">();</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">when</span> <span class="o">=</span> <span class="n">when</span><span class="o">;</span>
        <span class="n">msg</span><span class="o">.</span><span class="na">arg1</span> <span class="o">=</span> <span class="n">token</span><span class="o">;</span>
        <span class="c1">// 注意这里，并没有为target成员进行初始化</span>

        <span class="n">Message</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">Message</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
        <span class="c1">// 插入到队列中</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">when</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">when</span> <span class="o">&lt;=</span> <span class="n">when</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// invariant: p == prev.next</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="n">mMessages</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">token</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>可以看到，设置分割栏和普通的post Message是一样的，不同的是target是空的</p>

<p>下面接着来看看分割栏真正起作用的地方:</p>

<p>frameworks/base/core/java/android/os/MessageQueue.java</p>
<pre class="highlight java"><code><span class="n">Message</span> <span class="nf">next</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="c1">// 进行队列遍历</span>
        <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">mMessages</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">do</span> <span class="o">{</span>
                <span class="n">prevMsg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">;</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="c1">// 如果target为NULL，将会陷入这个循环，除非是有异步标志的消息才会跳出循环</span>
            <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">msg</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">msg</span><span class="o">.</span><span class="na">isAsynchronous</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>
<h2 id="跨进程异步消息: Messenger">跨进程异步消息: Messenger</h2>
<p>Messenger是Android开发中算是比较冷门的一种跨进程通信方式，它的实现是依托着Binder+Handler这两种技术的配合，使得跨进程调用后服务端任务能够在指定的线程中被执行</p>

<p>这种方式其实就类似于ActivityThread的binder call接收后，使用指定Handler去post消息是一样的，不同的在于Messenger的对其进行了封装，使得开发者可以轻松的实现而不需要更多的代码</p>

<p>原生有个典型实现的MessengerService，可以参考它的思路：</p>

<p>frameworks/base/core/tests/coretests/src/android/os/MessengerService.java</p>
<pre class="highlight java"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MessengerService</span> <span class="kd">extends</span> <span class="n">Service</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Handler</span> <span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Handler</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="n">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Message</span> <span class="n">reply</span> <span class="o">=</span> <span class="n">Message</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
            <span class="n">reply</span><span class="o">.</span><span class="na">copyFrom</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 这里的replyTo的mTarget实际上是对端的binder proxy，用以实现回调的功能</span>
                <span class="n">msg</span><span class="o">.</span><span class="na">replyTo</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">reply</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">};</span>

    <span class="c1">// 创建一个Messenger，mTarget将会创建一个binder stub，服务方法运行在mHandler所在线程</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Messenger</span> <span class="n">mMessenger</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Messenger</span><span class="o">(</span><span class="n">mHandler</span><span class="o">);</span>

    <span class="kd">public</span> <span class="n">MessengerService</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">IBinder</span> <span class="n">onBind</span><span class="o">(</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 返回的是被创建的Messenger服务binder句柄</span>
        <span class="k">return</span> <span class="n">mMessenger</span><span class="o">.</span><span class="na">getBinder</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<ol>
<li>服务端可以通过继承MessengerService，定义自己的业务</li>
<li>客户端通过bind该service，可以获取Messenger的binder proxy句柄，从而实现通信。调用到服务端后，操作将会运行在mHandler所在线程</li>
<li>replyTo是客户端指定的，用来接受服务端的回复</li>
</ol>
<h2 id="实现基础: epoll">实现基础: epoll</h2>
<p>epoll和select和poll一样都是I/O多路复用技术，和它们不同的是，epoll只关心"活跃"的链接，不需要遍历全部的描述符集合，能够处理大量的链接请求</p>

<p>以下是一个使用epoll的典型代码示例，主要分为三部：</p>

<ol>
<li>使用epoll_create创建epoll的fd</li>
<li>使用epoll_ctl将需要监听的fd添加到epoll中</li>
<li>使用epoll_wait等待事件</li>
</ol>
<pre class="highlight c"><code><span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">,</span> <span class="n">events</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">listen_sock</span><span class="p">,</span> <span class="n">conn_sock</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">epollfd</span><span class="p">;</span>

<span class="c1">// 创建epoll的文件描述符  
</span><span class="n">epollfd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epollfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_create1"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 将我们需要监听的文件描述符和事件通过epoll_ctl加入到epoll描述符中
</span><span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
<span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">listen_sock</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">listen_sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_ctl: listen_sock"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="c1">// 等待事件的发生
</span>    <span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_EVENTS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_wait"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 监听到事件，处理事件
</span>    <span class="p">...</span>
<span class="p">}</span></code></pre>

<p>epoll的实现很简单，简单到所有的主要逻辑都在单个文件中实现，文件路径在<code>kernel/msm-3.18/fs/eventpoll.c</code></p>

<p>下面接着分析epoll各个重要函数的源码</p>
<h3 id="epoll 初始化">epoll 初始化</h3>
<p>在使用epoll之前，系统需要在启动期间对epoll的基础设施进行初始化</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">eventpoll_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">si</span><span class="p">;</span>

    <span class="c1">// 获取系统内存状态
</span>    <span class="n">si_meminfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="p">);</span>
    <span class="c1">// 根据系统内存配置设置单个用户可见监听的最大epoll个数
</span>    <span class="n">max_user_watches</span> <span class="o">=</span> <span class="p">(((</span><span class="n">si</span><span class="p">.</span><span class="n">totalram</span> <span class="o">-</span> <span class="n">si</span><span class="p">.</span><span class="n">totalhigh</span><span class="p">)</span> <span class="o">/</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">/</span> <span class="n">EP_ITEM_COST</span><span class="p">;</span>

    <span class="c1">// 初始化调用队列，方便检查是否超过最大嵌套次数
</span>    <span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_loop_ncalls</span><span class="p">);</span>
    <span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_safewake_ncalls</span><span class="p">);</span>
    <span class="n">ep_nested_calls_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_readywalk_ncalls</span><span class="p">);</span>

    <span class="c1">// 创建用于分配epitem数据结构的的SLAB缓存
</span>    <span class="n">epi_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">"eventpoll_epi"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epitem</span><span class="p">),</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 创建用于分配eppoll_entry数据结构的SLAB缓存
</span>    <span class="n">pwq_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">"eventpoll_pwq"</span><span class="p">,</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">eppoll_entry</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 在系统启动过程中，init进程设备初始化时对epoll进行初始化
</span><span class="n">fs_initcall</span><span class="p">(</span><span class="n">eventpoll_init</span><span class="p">);</span></code></pre>

<p>epoll 初始化期间主要完成的三个工作:</p>

<ol>
<li>根据内存配置，初始化单个用户最大可见听epoll个数</li>
<li>初始化调用队列，以此来判断嵌套调用是超过上限</li>
<li>初始化SLAB内存缓存，以此来提升epoll使用内存的效率</li>
</ol>
<h3 id="epoll_create">epoll_create</h3>
<p>在native Looper.cpp的实现中，epoll_create的调用函数用以创建一个epoll，但是在内核源码中并没有直接发现epoll_create之类的函数</p>

<p>查阅资料后发现，内核将epoll系列的函数都使用了SYSCALL_DEFINE宏调用来实现了，SYSCALL_DEFINE后的数字x代表了该函数拥有x个参数，之所以使用这种方式来声明函数是为了修复64位Linux系统上的CVE-2009-2009漏洞</p>
<pre class="highlight c"><code><span class="c1">// 为了阅读源码的便捷性，可以直接将该宏调用看成 epoll_create(int flags);
</span><span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">epoll_create1</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>

    <span class="c1">// 初始化eventpoll结构
</span>    <span class="n">error</span> <span class="o">=</span> <span class="n">ep_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="p">);</span>
    <span class="c1">// 获取一个没有使用过的fd
</span>    <span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">));</span>

    <span class="c1">// 创建eventpoll文件，file_operations为eventpoll_fops
</span>    <span class="c1">// 同时将ep设置到file-&gt;private_data中
</span>    <span class="n">file</span> <span class="o">=</span> <span class="n">anon_inode_getfile</span><span class="p">(</span><span class="s">"[eventpoll]"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventpoll_fops</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span>
                 <span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CLOEXEC</span><span class="p">));</span>

    <span class="n">ep</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
    <span class="c1">// 将fd与文件进行关联
</span>    <span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>

<span class="n">out_free_fd</span><span class="o">:</span>
    <span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="n">out_free_ep</span><span class="o">:</span>
    <span class="n">ep_free</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>epoll_create的主要做了两个工作：</p>

<ol>
<li>新建并初始化一个epollpoll结构</li>
<li>创建eventpoll文件、获取一个空闲fd，并将两者进行关联</li>
</ol>
<h3 id="epoll_ctl">epoll_ctl</h3><pre class="highlight c"><code><span class="c1">// epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</span><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_ctl</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">full_check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fd</span> <span class="n">f</span><span class="p">,</span> <span class="n">tf</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">epds</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">tep</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ep_op_has_event</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="c1">// 将epoll_event信息使用mmap从native拷贝到kernel
</span>        <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)))</span>
        <span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>

    <span class="c1">// 获取mEpollFd, mWakeEventFd对应文件
</span>    <span class="n">f</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
    <span class="n">tf</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="c1">// 从文件的private_data中获取到eventpoll
</span>    <span class="n">ep</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

    <span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">// 通过file, fd在eventpoll的红黑树中进行查询，看是否存在已经保存的eventitem
</span>    <span class="n">epi</span> <span class="o">=</span> <span class="n">ep_find</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>

    <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="c1">// 进行op操作分流
</span>    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果未查询到，则创建并插入新的eventitem
</span>            <span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">file</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">full_check</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span>
            <span class="c1">// 如果查询到，则移除该eventitem
</span>            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_remove</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epi</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果查询到，则进行替换
</span>            <span class="n">epds</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ep_modify</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epds</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

<span class="n">error_tgt_fput</span><span class="o">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">full_check</span><span class="p">)</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epmutex</span><span class="p">);</span>

    <span class="n">fdput</span><span class="p">(</span><span class="n">tf</span><span class="p">);</span>
<span class="n">error_fput</span><span class="o">:</span>
    <span class="n">fdput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="n">error_return</span><span class="o">:</span>

    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>epoll_ctl主要做了两个工作：</p>

<ol>
<li>将epoll_event信息使用mmap拷贝到内核中</li>
<li>通过fd获取到对应的file文件，并通过private_data获取到eventpoll</li>
<li>通过file,fd在eventpoll中进行查询，看是否存在对应的eventitem</li>
<li>根据查询到的eventitem进行对应的操作</li>
</ol>

<p>这里详细分析下<code>ep_insert</code>方法:</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span>
             <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full_check</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">revents</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">user_watches</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ep_pqueue</span> <span class="n">epq</span><span class="p">;</span>

    <span class="c1">// 使用SLAB内存分配器创建eventitem
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">)))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="c1">// 初始化链表节点
</span>    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
    <span class="c1">// 初始化基础属性
</span>    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
    <span class="n">ep_set_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">,</span> <span class="n">tfile</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>

    <span class="c1">// 初始化poll表，并注册回调函数ep_ptable_queue_proc
</span>    <span class="n">epq</span><span class="p">.</span><span class="n">epi</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
    <span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">ep_ptable_queue_proc</span><span class="p">);</span>

    <span class="c1">// 调用被插入文件的poll方法，最终会将当前epollitem放入到ready list并唤醒eventpoll中的等待进程
</span>    <span class="n">revents</span> <span class="o">=</span> <span class="n">ep_item_poll</span><span class="p">(</span><span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">);</span>

    <span class="cm">/* Add the current item to the list of active epoll hook for this file */</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>
    <span class="c1">// 将fllink加入到文件的f_ep_links列表中作为子项
</span>    <span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_ep_links</span><span class="p">);</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_lock</span><span class="p">);</span>

    <span class="c1">// 将epollitem的rbn红黑树节点插入到eventpoll中的rbr红黑树中
</span>    <span class="c1">// 注意一点的是，节点的是根据epoll_filefd来比对的
</span>    <span class="n">ep_rbtree_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">epi</span><span class="p">);</span>

    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span>
        <span class="n">ep_pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>

        <span class="c1">// 唤醒该队列
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
            <span class="n">wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
            <span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">epoll_watches</span><span class="p">);</span>

    <span class="c1">// 唤醒并调用该队列中的事件
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
        <span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span></code></pre>

<p>epoll_ctl主要做了三个工作：</p>

<ol>
<li>创建并初始化eventitem</li>
<li>为poll_wait函数初始化，当设备唤醒时会执行回调函数</li>
<li>检查当前设备状态，如果已经就绪那么直接唤醒等待队列</li>
</ol>
<h3 id="epoll_wait">epoll_wait</h3><pre class="highlight c"><code><span class="c1">// epoll_wait(int epfd, epoll_event *events, int maxevents, int timeout)
</span><span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">epoll_wait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fd</span> <span class="n">f</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>

    <span class="c1">// 通过fd获取到文件信息
</span>    <span class="n">f</span> <span class="o">=</span> <span class="n">fdget</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>

    <span class="c1">// 通过private_data获取到eventpoll
</span>    <span class="n">ep</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

    <span class="c1">// 调用ep_poll获取就绪的事件，并将它们派发到接收者的事件缓冲中
</span>    <span class="n">error</span> <span class="o">=</span> <span class="n">ep_poll</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

<span class="n">error_fput</span><span class="o">:</span>
    <span class="n">fdput</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>epoll_wait的操作很简单，通过fd检索到相关eventpoll后马上调用核心函数<code>ep_poll</code>，这里详细分析一下：</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eavail</span><span class="p">,</span> <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">slack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wait_queue_t</span> <span class="n">wait</span><span class="p">;</span>
    <span class="n">ktime_t</span> <span class="n">expires</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">timespec</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">ep_set_mstimeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>

        <span class="n">slack</span> <span class="o">=</span> <span class="n">select_estimate_accuracy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_time</span><span class="p">);</span>
        <span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">expires</span><span class="p">;</span>
        <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="n">end_time</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果未设置超时事件，则直接获取事件，不进行阻塞
</span>        <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">check_events</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">fetch_events:</span>
    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 使用队列进行睡眠，直到ep_poll_callback被调用，队列被唤醒，才会接着执行下去
</span>        <span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
        <span class="n">__add_wait_queue_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
            <span class="c1">// 如果事件到来则退出循环
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span> <span class="o">||</span> <span class="n">timed_out</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">freezable_schedule_hrtimeout_range</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">slack</span><span class="p">,</span>
                                <span class="n">HRTIMER_MODE_ABS</span><span class="p">))</span>
                <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

        <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">check_events:</span>
    <span class="c1">// 是否存在入队的事件
</span>    <span class="n">eavail</span> <span class="o">=</span> <span class="n">ep_events_available</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="c1">// 取出事件并发送到客户端进程
</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">eavail</span> <span class="o">&amp;&amp;</span>
        <span class="o">!</span><span class="p">(</span><span class="n">res</span> <span class="o">=</span> <span class="n">ep_send_events</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">maxevents</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timed_out</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">fetch_events</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span></code></pre>

<p>ep_poll的主要操作在于从eventpoll中取出已经准备就绪的eventitem，随后调用<code>ep_send_events</code>，通过timeout参数判断是否需要阻塞以及需要阻塞的时间</p>
<pre class="highlight c"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_send_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
              <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="n">esed</span><span class="p">;</span>

    <span class="n">esed</span><span class="p">.</span><span class="n">maxevents</span> <span class="o">=</span> <span class="n">maxevents</span><span class="p">;</span>
    <span class="n">esed</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">;</span>

    <span class="c1">// ep_send_events_proc 为扫描回调函数
</span>    <span class="k">return</span> <span class="n">ep_scan_ready_list</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ep_send_events_proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">esed</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_scan_ready_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="p">,</span>
                       <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
                  <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ep_locked</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">,</span> <span class="o">*</span><span class="n">nepi</span><span class="p">;</span>
    <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">txlist</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">// 调用ep_send_events_proc进行回调
</span>    <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">sproc</span><span class="p">)(</span><span class="n">ep</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txlist</span><span class="p">,</span> <span class="n">priv</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_send_events_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ep_send_events_data</span> <span class="o">*</span><span class="n">esed</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">eventcnt</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">revents</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uevent</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">wakeup_source</span> <span class="o">*</span><span class="n">ws</span><span class="p">;</span>
    <span class="n">poll_table</span> <span class="n">pt</span><span class="p">;</span>

    <span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">eventcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uevent</span> <span class="o">=</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">;</span>
         <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">eventcnt</span> <span class="o">&lt;</span> <span class="n">esed</span><span class="o">-&gt;</span><span class="n">maxevents</span><span class="p">;)</span> <span class="p">{</span>
        <span class="c1">// 从rdlink列表中获取到epollitem
</span>        <span class="n">epi</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epitem</span><span class="p">,</span> <span class="n">rdllink</span><span class="p">);</span>

        <span class="n">ws</span> <span class="o">=</span> <span class="n">ep_wakeup_source</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ws</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ws</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">)</span>
                <span class="n">__pm_stay_awake</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
            <span class="n">__pm_relax</span><span class="p">(</span><span class="n">ws</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>

        <span class="c1">// 从设备中读取事件
</span>        <span class="n">revents</span> <span class="o">=</span> <span class="n">ep_item_poll</span><span class="p">(</span><span class="n">epi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">revents</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 使用mmap将事件发送到客户端
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">revents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">||</span>
                <span class="n">__put_user</span><span class="p">(</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uevent</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
                <span class="n">ep_pm_stay_awake</span><span class="p">(</span><span class="n">epi</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">eventcnt</span> <span class="o">?</span> <span class="n">eventcnt</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">eventcnt</span><span class="p">;</span>
<span class="p">}</span></code></pre>
<h3 id="epoll中的生产者消费者模型">epoll中的生产者消费者模型</h3>
<ul>
<li>生产者: 由<code>epoll_ctl</code>最终调用的<code>ep_insert</code>触发，在驱动唤醒等待队列后会调用<code>ep_poll_callback</code>方法将epollitem添加到epollevent的<code>rdllist</code>中</li>
<li>消费者: 由<code>epoll_wait</code>最终调用的<code>ep_poll</code>触发，在等待队列响应后会继续执行，从<code>rdllist</code>中取出epoll_item，随后读取设备</li>
</ul>
                    </div>
                </div>
                <div class="topic-tags">
</div>
                <div class="topic-vertical-btns hidden">
  <button class="button xzl-primary-btn topic-favorite-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-topic-id="6932" data-favorite="false" data-topic-count="false">
    <span class="xzl-default-state-btn">
      <span class="svgIcon svgIcon--heart svgIcon--25px is-flushLeft">
        <svg class="svgIcon-use topic-unfavorited " width="25" height="25" viewBox="0 0 25 25">
          <path d="M12.5 21a.492.492 0 0 1-.327-.122c-.278-.24-.61-.517-.978-.826-2.99-2.5-7.995-6.684-7.995-10.565C3.2 6.462 5.578 4 8.5 4c1.55 0 3 .695 4 1.89a5.21 5.21 0 0 1 4-1.89c2.923 0 5.3 2.462 5.3 5.487 0 3.97-4.923 8.035-7.865 10.464-.42.35-.798.66-1.108.93a.503.503 0 0 1-.327.12zM8.428 4.866c-2.414 0-4.378 2.05-4.378 4.568 0 3.475 5.057 7.704 7.774 9.975.243.2.47.39.676.56.245-.21.52-.43.813-.68 2.856-2.36 7.637-6.31 7.637-9.87 0-2.52-1.964-4.57-4.377-4.57-1.466 0-2.828.76-3.644 2.04-.1.14-.26.23-.43.23-.18 0-.34-.09-.43-.24-.82-1.27-2.18-2.03-3.65-2.03z"
          fill-rule="evenodd">
          </path>
        </svg>
        <svg class="svgIcon-use topic-favorited hidden" width="25" height="25" viewBox="0 0 25 25">
          <path d="M12.5 21a.492.492 0 0 1-.327-.122c-.278-.24-.61-.517-.978-.826-2.99-2.5-7.995-6.684-7.995-10.565C3.2 6.462 5.578 4 8.5 4c1.55 0 3 .695 4 1.89a5.21 5.21 0 0 1 4-1.89c2.923 0 5.3 2.462 5.3 5.487 0 3.97-4.923 8.035-7.865 10.464-.42.35-.798.66-1.108.93a.503.503 0 0 1-.327.12z"
          fill-rule="evenodd">
          </path>
        </svg>
      </span>
    </span>
  </button>
</div>
                <div class="topic-rights">
                  <span>© 著作权归作者所有</span>
                </div>
                <div class="reward-partial">
      <div class="reward-partial-for-tip">
  <span class="tip">这个作品真棒，我要支持一下！</span>
</div>
<div class="reward-partial-for-reward">
      <button class="button button--small reward-btn  xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn">
        <span class="button-label  xzl-default-state-btn ">
          赞赏
        </span>
      </button>
</div>
<div class="rewarded-users">
</div>
    </div>
    <div class="topic-footer">
  <div class="favorite-partial topic-favorite-btn-item">
    <button class="button xzl-primary-btn topic-favorite-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-topic-id="6932" data-favorite="false" data-topic-count="false">
      <span class="xzl-default-state-btn">
        <span class="svgIcon svgIcon--heart topic-btn">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20px" height="20px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use topic-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"></path>
        </g>
    </g>
</svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="21px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use topic-unfavorited-hover ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -347.000000)" stroke="#2D2E2F">
            <path d="M211.978949,366.95489 C211.926485,366.972967 211.87389,366.990773 211.821167,367.008306 L212.136732,367.008306 C212.084007,366.990772 212.031412,366.972966 211.978949,366.95489 Z M201.505033,353.185818 C201.502008,353.093677 201.501932,353.092246 201.499329,353.043074 L201,353.068966 L201,353.568966 L201.482808,353.568966 L201.505033,353.185818 Z M211.978949,366.95489 C206.754996,365.155011 202.831944,360.676332 201.767482,355.227148 C201.586643,354.622169 201.5,354.041319 201.5,353.448276 C201.5,353.363399 201.501775,353.278748 201.505314,353.194357 C201.505217,353.191426 201.505124,353.188582 201.505033,353.185818 L201.510132,353.09792 C201.69196,349.963332 204.293503,347.5 207.448276,347.5 C209.044187,347.5 210.539021,348.130705 211.647055,349.234935 L212,349.586669 L212.352945,349.234935 C213.460979,348.130705 214.955813,347.5 216.551724,347.5 C219.836866,347.5 222.5,350.163134 222.5,353.448276 C222.5,354.151387 222.378189,354.837062 222.142953,355.483227 C220.970297,360.856032 217.094635,365.192275 211.978949,366.95489 Z" id="icon_like_hover"></path>
        </g>
    </g>
</svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20px" height="20px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use topic-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"></path>
        </g>
    </g>
</svg>

        </span>
      </span>
    </button>
    <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-6932 u-disablePointerEvents">
      赞
    </button>
  </div>
  <div class="topic-other-btns ">
    <div class="xzl-topic-btn topic-collect-btn-item">
      <button class="button xzl-button-chrome-less topic-collect  topic-collect-btn is-touchIconFadeInPulse  button--withIcon button--withSvgIcon button--bookmark js-bookmarkButton" data-topic-id="6932" data-collect="false" data-topic-count="false">
        <span class="xzl-default-state-btn topic-uncollected ">
          <span class="svgIcon svgIcon--bookmark topic-btn">
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="21px" viewBox="0 0 16 22" version="1.1" class="svgIcon-use unmark-btn">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-534.000000, -222.000000)" stroke="#818181">
            <g id="icon_mark_normal" transform="translate(534.000000, 222.000000)">
                <path d="M0.5,20.6397122 L8,18.1407585 L15.5,20.6397122 L15.5,3.00002705 C15.5,1.61420677 14.3800496,0.5 12.9905224,0.5 L3.00947762,0.5 C1.61641364,0.5 0.5,1.61566259 0.5,3.00002705 L0.5,20.6397122 Z" id="icon_mark"></path>
            </g>
        </g>
    </g>
</svg>

            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="21px" viewBox="0 0 16 21" version="1.1" class="svgIcon-use unmark-hover-btn">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-534.000000, -345.000000)" stroke="#2D2E2F">
            <g id="icon_mark_hover" transform="translate(534.000000, 345.000000)">
                <path d="M0.5,20.309799 L8,17.8498915 L15.5,20.309799 L15.5,3.00878799 C15.5,1.62231116 14.3770475,0.5 12.9905224,0.5 L3.00947762,0.5 C1.61674031,0.5 0.5,1.61924805 0.5,3.00878799 L0.5,20.309799 Z" id="icon_mark"></path>
            </g>
        </g>
    </g>
</svg>

          </span>
        </span>
        <span class="topic-collected hidden">
          <span class="svgIcon svgIcon--bookmarkFilled topic-btn">
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="21px" viewBox="0 0 16 22" version="1.1" class="svgIcon-use">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-534.000000, -418.000000)" fill="#2D2E2F">
            <path d="M534,421.000027 C534,419.343158 535.336631,418 537.009478,418 L546.990522,418 C548.652611,418 550,419.334496 550,421.000027 L550,439.333333 L542,436.667783 L534,439.333333 L534,421.000027 Z" id="icon_mark_press"></path>
        </g>
    </g>
</svg>

          </span>
        </span>
      </button>
      <button class="button xzl-button-chrome-less xzl-base-color-normal-btn  collections-count collections-count-for-6932 u-disablePointerEvents"
        data-action="show-recommends" data-action-value="ca48fab0cac2">
          收藏
      </button>  
    </div>
    <div class="xzl-topic-btn topic-share-btn-item">
      <button class="button xzl-button-chrome-less topic-share-btn is-touchIconFadeInPulse  button--withIcon button--withSvgIcon button--bookmark js-bookmarkButton">
        <span class="xzl-default-state-btn topic-uncollected">
          <span class="svgIcon svgIcon--bookmark topic-btn">
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="19px" height="21px" viewBox="0 0 19 21" version="1.1" class="btn-unhover">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-1072.000000, -221.000000)" fill-rule="nonzero" fill="#818181">
            <g id="icon_share_normal" transform="translate(1072.000000, 221.000000)">
                <path d="M10,1.70710678 L10,16 L9,16 L9,1.94974747 L6.70710678,4.24264069 L6,3.53553391 L9.53553391,-9.59232693e-14 L9.62132034,0.0857864376 L9.70710678,-9.59232693e-14 L13.2426407,3.53553391 L12.5355339,4.24264069 L10,1.70710678 Z M6.98406982,6 L6.98406982,7 L2.00135411,7 C1.44882877,7 1,7.44628753 1,7.99188419 L1,19.0081158 C1,19.5543728 1.44661828,20 1.99742191,20 L17.0025781,20 C17.5559942,20 18,19.5567115 18,19.0081158 L18,7.99188419 C18,7.44560951 17.5534348,7 17.0027359,7 L11.9909668,7 L11.9909668,6 L17.0027359,6 C18.1057944,6 19,6.89339733 19,7.99188419 L19,19.0081158 C19,20.1082031 18.1090746,21 17.0025781,21 L1.99742191,21 C0.894276248,21 0,20.1066027 0,19.0081158 L0,7.99188419 C0,6.89179693 0.898747194,6 2.00135411,6 L6.98406982,6 Z" id="Shape"></path>
            </g>
        </g>
    </g>
</svg>

            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="19px" height="21px" viewBox="0 0 19 21" version="1.1" class="btn-hovered">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-1072.000000, -284.000000)" fill-rule="nonzero" fill="#2D2E2F">
            <g id="icon_share_press" transform="translate(1072.000000, 284.000000)">
                <path d="M10,1.70710678 L10,16 L9,16 L9,1.94974747 L6.70710678,4.24264069 L6,3.53553391 L9.53553391,-1.13686838e-13 L9.62132034,0.0857864376 L9.70710678,-1.13686838e-13 L13.2426407,3.53553391 L12.5355339,4.24264069 L10,1.70710678 Z M6.98406982,6 L6.98406982,7 L2.00135411,7 C1.44882877,7 1,7.44628753 1,7.99188419 L1,19.0081158 C1,19.5543728 1.44661828,20 1.99742191,20 L17.0025781,20 C17.5559942,20 18,19.5567115 18,19.0081158 L18,7.99188419 C18,7.44560951 17.5534348,7 17.0027359,7 L11.9909668,7 L11.9909668,6 L17.0027359,6 C18.1057944,6 19,6.89339733 19,7.99188419 L19,19.0081158 C19,20.1082031 18.1090746,21 17.0025781,21 L1.99742191,21 C0.894276248,21 0,20.1066027 0,19.0081158 L0,7.99188419 C0,6.89179693 0.898747194,6 2.00135411,6 L6.98406982,6 Z" id="Shape"></path>
            </g>
        </g>
    </g>
</svg>

          </span>
        </span>
      </button>
      <button class="button xzl-button-chrome-less xzl-base-color-normal-btn share-text  collections-count u-disablePointerEvents"
        data-action="show-recommends" data-action-value="ca48fab0cac2">
          分享
        
      </button>
    </div>
      <div class="xzl-topic-btn topic-reprint-btn-item">
        <button class="button xzl-button-chrome-less reprint-btn topic-reprint-btn is-touchIconFadeInPulse  button--withIcon button--withSvgIcon button--bookmark js-bookmarkButton">
          <span class="xzl-default-state-btn topic-uncollected">
            <span class="svgIcon svgIcon--bookmark topic-btn">
              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="23px" height="21px" viewBox="0 0 23 21" version="1.1" class="btn-unhover">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-783.000000, -221.000000)" stroke="#818181">
            <g id="icon_transport_normal" transform="translate(783.000000, 221.000000)">
                <path d="M0.620499195,19.6260789 C0.689774669,19.6000793 0.876367811,19.410893 1.14703386,19.018654 C1.22460981,18.9062339 1.99011688,17.7148837 2.26997018,17.3225109 L2.27162961,17.3201848 C4.76238917,13.8294641 8.63937114,11.5496832 12.9544008,11.1256372 L13.5033012,11.0716957 L13.5033012,14.4053433 C13.5033012,15.0795642 13.7000275,15.1721039 14.2205525,14.737934 L21.9568395,8.28509759 C22.5566887,7.78476341 22.5404655,7.04226228 21.915794,6.56493142 L14.294968,0.741622353 C13.7392626,0.316990668 13.5033012,0.432990692 13.5033012,1.12435459 L13.5033012,4.11604062 L13.0522015,4.16037103 C5.95973399,4.85736114 0.503301161,10.8422818 0.503301161,18.0213137 C0.503301161,18.1416723 0.502883115,18.2315328 0.501639697,18.4238454 C0.494858406,19.4516318 0.516834709,19.5941383 0.620499195,19.6260789 Z" id="Combined-Shape"></path>
            </g>
        </g>
    </g>
</svg>

              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="23px" height="21px" viewBox="0 0 23 21" version="1.1" class="btn-hovered">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-783.000000, -285.000000)" stroke="#2D2E2F">
            <path d="M783.620499,304.626079 C783.689775,304.600079 783.876368,304.410893 784.147034,304.018654 C784.22461,303.906234 784.990117,302.714884 785.26997,302.322511 L785.27163,302.320185 C787.762389,298.829464 791.639371,296.549683 795.954401,296.125637 L796.503301,296.071696 L796.503301,299.405343 C796.503301,300.079564 796.700027,300.172104 797.220552,299.737934 L804.95684,293.285098 C805.556689,292.784763 805.540465,292.042262 804.915794,291.564931 L797.294968,285.741622 C796.739263,285.316991 796.503301,285.432991 796.503301,286.124355 L796.503301,289.116041 L796.052202,289.160371 C788.959734,289.857361 783.503301,295.842282 783.503301,303.021314 C783.503301,303.141672 783.502883,303.231533 783.50164,303.423845 C783.494858,304.451632 783.516835,304.594138 783.620499,304.626079 Z" id="icon_transport_press"></path>
        </g>
    </g>
</svg>

            </span>
          </span>
        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn reprint-text u-disablePointerEvents"
          data-action="show-recommends">
            转载
        </button>
      </div>
  </div>
</div>




<script type="text/javascript">
  // $(".wechat-qrcode-img").qrcode({
  //   render: "canvas",
  //   text: $(".wechat-qrcode-img").data("url"),
  //   height: 70,
  //   width: 70,
  // })

 
  $(window).on("click.Bst", function(e) {
    if(!$(event.target).closest('.xzl-invite-icon').length){
      //$(".xzl-invite-card").fadeOut()
    }else{
    }
  })

  
</script>
<script type="text/javascript">
  $(".topic-reprint-btn-item").click(function(){
    $(".topic-reprint-modal").removeClass("hidden")
  })

  
</script>
      <div class="topic-show-zhuanlan">
    <div class="streamItem-card">
      <div class="zhuanlan">
        <div class="zl-header">
          <a href="/cheaptalks">
            <img class="avatar zhuanlan-logo-with-border" src="https://diycode.b0.upaiyun.com/photo/2017/a8e511e6d45335f875a7f710b34ae9c9.jpg" alt="A8e511e6d45335f875a7f710b34ae9c9" />
</a>        </div>
        <div class="zl-body">
          <div class="zl-title"><a href="/cheaptalks">从源码角度看 Android</a></div>
          <div class="zl-bio">作者简介:

小米 MIUI 系统工程师、港中文计算机研究生，喜欢 Android，享受每次技术上突破的感觉~

...</div>
        </div>
        <div class="zl-footer">
              <button class="button button--small subscribed has-subscribed-btn xzl-btn-with-chrome xzl-base-color-normal-btn">
                <span class="button-label  xzl-default-state-btn">
                  已经订阅
                </span>
              </button>
        </div>
      </div>
    </div>
    
  </div>

    <div class="comment-list-title-header u-block">
  <span class="comment-list-title">
    4条评论
  </span>
</div>
<div class="comments-list">
    <div class="comment-partial" id="reply1">
  <div class="comment-header">
    <div class="avatar">
      <a href="/u/7631660320">
        <img class="user-avatar" src="https://diycode.b0.upaiyun.com/photo/2017/1871696ff63e3cbb78490f5c9dc8e978.jpeg" alt="1871696ff63e3cbb78490f5c9dc8e978" />
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="/u/7631660320">罗占伟 David</a>
        <div class="floor">
          <span>#1</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>666666</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-07-26T21:39:21+08:00"></abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="1" data-user-id="5794" data-user-name="罗占伟 David">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewBox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"></path>
                </g>
            </g>
        </g>
    </g>
</svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-6932 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id=2657  data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"></path>
        </g>
    </g>
</svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"></path>
        </g>
    </g>
</svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-6932 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply2">
  <div class="comment-header">
    <div class="avatar">
      <a href="/u/5401825586">
        <img class="user-avatar" src="https://diycode.b0.upaiyun.com/photo/2018/fba1c04cf6292983d5231d4b426707f3." alt="Fba1c04cf6292983d5231d4b426707f3" />
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="/u/5401825586">Kenneth75</a>
        <div class="floor">
          <span>#2</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>ThreadLocal这个静态变量应该是线程共享的吧，架构图是不是画错了。。。</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-09-10T13:39:29+08:00"></abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="2" data-user-id="70109" data-user-name="Kenneth75">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewBox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"></path>
                </g>
            </g>
        </g>
    </g>
</svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-6932 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id=3474  data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"></path>
        </g>
    </g>
</svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"></path>
        </g>
    </g>
</svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-6932 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply3">
  <div class="comment-header">
    <div class="avatar">
      <a href="/u/4194525383">
        <img class="user-avatar" src="https://diycode.b0.upaiyun.com/photo/2018/6c4b478479c800e75f20ad531065e60e.png!small" alt="6c4b478479c800e75f20ad531065e60e" />
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="/u/4194525383">bongor</a>
        <div class="floor">
          <span>#3</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p><a href="#reply2" class="at_floor" data-floor="2">#2楼</a> <a href="/u/5401825586" target="_blank" class="at_user" title="@5401825586"><i>@</i>Kenneth75</a> ThreadLocal的作用就是维护每个线程一个Looper</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-10-19T14:25:09+08:00"></abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="3" data-user-id="23142" data-user-name="bongor">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewBox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"></path>
                </g>
            </g>
        </g>
    </g>
</svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-6932 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id=4076  data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"></path>
        </g>
    </g>
</svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"></path>
        </g>
    </g>
</svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-6932 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply4">
  <div class="comment-header">
    <div class="avatar">
      <a href="/u/1606180959">
        <img class="user-avatar" src="https://diycode.b0.upaiyun.com/photo/2017/a321ca193c6e719b40bfeea738061adc.jpeg" alt="A321ca193c6e719b40bfeea738061adc" />
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="/u/1606180959">杨天睿</a>
        <div class="floor">
          <span>#4</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>您好，请教一个问题，可以理解为Looper是通过epoll监听eventFd的变化来实现阻塞的么？Looper的pollInner()中epoll被唤醒后，会调用awoken()，awoken()会去读eventFd的值，但是awoken()这处逻辑有什么用么？不读eventFd的话，仍然能被唤醒。</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2019-03-17T18:31:34+08:00"></abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="4" data-user-id="14046" data-user-name="杨天睿">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewBox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"></path>
                </g>
            </g>
        </g>
    </g>
</svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-6932 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id=5475  data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"></path>
        </g>
    </g>
</svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewBox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"></path>
        </g>
    </g>
</svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-6932 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

</div>

  <div class="write-comment">
    <div class="avatar">
      <img class="user-avatar" src="https://diycode.b0.upaiyun.com/photo/2018/8d63845d9d9fd12b9f298314160110e7." alt="8d63845d9d9fd12b9f298314160110e7" />
    </div>
    <textarea class="comment-input"  id="comment-input" type="text"   rows="1"  placeholder="写下你的评论"></textarea> 
  </div>
  <div class="publish-commnt-button">
    <button class="button xzl-primary-btn comment-publish-btn  pull-right xzl-basic-btn hidden xzl-btn-with-chrome disabled" data-topic-id=6932 disbaled>
      <span class="button-label  xzl-default-state-btn js-buttonLabel" >
        发表评论
      </span>
    </button>
  </div>
<script type="text/javascript">
  var formatCommentPublishBtn = function(){
    var text = $(".comment-input").val()
    if(!text){
      $(".comment-publish-btn").addClass("disabled")
    }else{
      $(".comment-publish-btn").removeClass("disabled")
    }
  }
  autosize(document.getElementById('comment-input'));
  $(".comment-input").focus(function(){
    $(".comment-publish-btn").removeClass("hidden")
    formatCommentPublishBtn()
  })
  $(".comment-input").keyup(function(){
    formatCommentPublishBtn()
  })
  $(".comment-input").blur(function(){
    if(!$(".comment-input").val()){
      $(".comment-publish-btn").addClass("hidden")
    }else{
      $(".comment-publish-btn").removeClass("hidden")
    }
  })

  window.replayPartial = function(){
    $(".reply-partial").unbind("click")
    $(".reply-partial").click(function(){
      var floor = $(this).data("floor")
      var userId = $(this).data("user-id")
      var userName = $(this).data("user-name")
      $(".comment-publish-btn").attr("data-user-id", "" + userId)
      $(".comment-input").val(" #" + floor + "楼 @" + userName + " "  ).focus()
    })
  }

  window.replayPartial()

  // $(".comment-partial").blur((function(){
  //   $(this).find(".reply-partial").addClass("hidden")
  // }))
</script>
    <div class="overlay topic-reward-modal hidden overlay--dark">
  <div class="overlay-dialog overlay-dialog--signin overlay-dialog--animate js-overlayDialog"
  tabindex="-1">
    <div class="close">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="16px" viewBox="0 0 16 16" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-273.000000, -154.000000)" id="icon_close_2" fill="#818181">
            <path d="M281,160.59766 L274.691197,154.288858 C274.296436,153.894097 273.674377,153.899886 273.287131,154.287131 C272.897186,154.677077 272.900659,155.302999 273.288858,155.691197 L279.59766,162 L273.288858,168.308803 C272.894097,168.703564 272.899886,169.325623 273.287131,169.712869 C273.677077,170.102814 274.302999,170.099341 274.691197,169.711142 L281,163.40234 L287.308803,169.711142 C287.703564,170.105903 288.325623,170.100114 288.712869,169.712869 C289.102814,169.322923 289.099341,168.697001 288.711142,168.308803 L282.40234,162 L288.711142,155.691197 C289.105903,155.296436 289.100114,154.674377 288.712869,154.287131 C288.322923,153.897186 287.697001,153.900659 287.308803,154.288858 L281,160.59766 Z"></path>
        </g>
    </g>
</svg>

    </div>
    <div class="overlay-actions">
      <div class="reward-header">
        <div class="avatar">
          <a href="/u/1253528474">
            <img class="user-avatar" src="https://diycode.b0.upaiyun.com/photo/2017/0137eba3bc45d85d51dffc218dff50ed.jpeg" alt="0137eba3bc45d85d51dffc218dff50ed" />
</a>        </div>
        <div class="user-name">
          <a href="/u/1253528474">
            RickAi
</a>        </div>
      </div>
      <div class="reward-body">
        <div class="reward-price reward-body-item">
          <span class="user-tip-label">赞赏金额</span>
          <div class='prices'>
            <button class="button button--small price reward-price-btn price-btn  selected reward-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" price=2>
              <span class="button-label  xzl-default-state-btn ">
                2元
              </span>
            </button>
            <button class="button button--small price reward-price-btn price-btn reward-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" price=5>
              <span class="button-label  xzl-default-state-btn ">
                5元
              </span>
            </button>
            <button class="button button--small price reward-price-btn price-btn reward-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" price=10>
              <span class="button-label  xzl-default-state-btn ">
                10元
              </span>
            </button>
          </div>
        </div>
        <div class="custom-price-div">
          <a href="javascript:void(0)" class="custom-price">自定义金额</a>
          <div class='message reward-body-item  hidden'>
            <input class="custom-price-input" placeholder="你想赞赏的金额（不超过20000元）" />
            <button class="button button--small custom-price-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-gray-btn xzl-base-color-normal-btn" data-topic-id=6932>
              <span class="button-label  xzl-default-state-btn ">
                确定
              </span>
            </button>
          </div>
          <div class="confirmed-custom-price-div hidden">
            <span class="confirmed-custom-price">2222元</span>
          </div>
        </div>
        <div class="pay-way reward-body-item">
          <span class="user-tip-label">支付方式</span>
          <div class="wechat-pay-way pay-way-button selected" data-value="wechat">
            <img class="wechat-pay-logo" src="https://diycode.b0.upaiyun.com/assets/svgs/wechat-e7cc39b856533cdc49437c7235aa3a12525480633f79fb7d9164005112ae4d90.svg" alt="Wechat" />
            <span class='tip'>微信支付</span>
          </div>
          <div class="alipay-pay-way pay-way-button hidden">
            <span class='tip'>支付宝支付</span>
          </div>
          <div class="wallet-pay-way pay-way-button wallet-btn"  data-value="wallet" data-amount="0">
            <span class='tip'>钱包余额：¥0</span>
          </div>
        </div>
      </div>
      <div class="reward-footer">
        <button class="button button--small pay-confirm-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" data-topic-id=6932>
          <span class="button-label  xzl-default-state-btn ">
            立即支付
          </span>
        </button>
      </div>
    </div>
  </div>
</div>
<div class="qrcode-for-reward">
</div>
<script type="text/javascript">

  $(".custom-price-btn").click(function(){
    const price = $(".custom-price-input").val()
    if(!price){
      alert("自定义价格不能为空")
      return
    }
    if(isNaN(price)){
      alert("自定义价格必须是数字")
      return
    }

    const priceFloat = parseFloat(price)
    if(priceFloat > 20000){
      alert("金额不能超过20000元")
      return
    }

    const pricePrecision = parseInt(priceFloat*10*10)/100
    if (pricePrecision != priceFloat){
      alert("金额只能精确到分")
      return
    }
    $(".confirmed-custom-price-div").html(price + "元")
    $(".custom-price-div .reward-body-item").addClass("hidden")
    $(".confirmed-custom-price-div").removeClass("hidden")
  })


  $(".confirmed-custom-price-div").click(function(){
    $(".custom-price-div .reward-body-item").removeClass("hidden")
    $(".confirmed-custom-price-div").addClass("hidden")
  })

  window.checkWalletAmount = function(){
    //var topicId = $(this).data("topic-id")
    var price = $(".custom-price-input").val()
    if(!price){
      price = $(".price-btn.selected").attr("price")
    }
    price = parseFloat(price)
    if(price <= 0 || price > 20000){
      $(".pay-confirm-btn").attr("disabled", true)
      $(".pay-confirm-btn span").text("金额不正确")
      return
    }
    var walletAmount = parseFloat($(".wallet-pay-way").data("amount"))
    if(price > walletAmount && $(".pay-way-button.selected").data("value") == "wallet"){
      $(".pay-confirm-btn").attr("disabled", true)
      $(".pay-confirm-btn span").text("余额不足")
    }else{
      $(".pay-confirm-btn").removeAttr("disabled")
      $(".pay-confirm-btn span").text("立即支付")
    }
  }

  $(".pay-way-button").unbind("click")
  $(".pay-way-button").click(function(){
    $(".pay-way-button").removeClass("selected")
    $(this).addClass("selected")
    window.checkWalletAmount()
  })

  $(".custom-price").click(function(){
    $(this).addClass("hidden")
    $(".reward-price-btn").removeClass("selected")
    $(".reward-body-item").removeClass("hidden")
  })

  $(".custom-price-input").on("input", function(){
    window.checkWalletAmount()
  })


</script>
    <div class="overlay wechat-pay-success-modal overlay--dark new-session-modal hidden">
  <div class="overlay-dialog overlay-dialog--animate js-overlayDialog"
  tabindex="-1">
    <div class="close">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="16px" viewBox="0 0 16 16" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-273.000000, -154.000000)" id="icon_close_2" fill="#818181">
            <path d="M281,160.59766 L274.691197,154.288858 C274.296436,153.894097 273.674377,153.899886 273.287131,154.287131 C272.897186,154.677077 272.900659,155.302999 273.288858,155.691197 L279.59766,162 L273.288858,168.308803 C272.894097,168.703564 272.899886,169.325623 273.287131,169.712869 C273.677077,170.102814 274.302999,170.099341 274.691197,169.711142 L281,163.40234 L287.308803,169.711142 C287.703564,170.105903 288.325623,170.100114 288.712869,169.712869 C289.102814,169.322923 289.099341,168.697001 288.711142,168.308803 L282.40234,162 L288.711142,155.691197 C289.105903,155.296436 289.100114,154.674377 288.712869,154.287131 C288.322923,153.897186 287.697001,153.900659 287.308803,154.288858 L281,160.59766 Z"></path>
        </g>
    </g>
</svg>

    </div>
    <div class="overlay-actions xzl-button-set">
      <img class="pay-success-logo" src="https://diycode.b0.upaiyun.com/assets/svgs/pay-success-9d4074188ff3710b3587bf93ef297b98d647346b7f25f918be77ad1a6aa531c4.png" alt="Pay success" />
      <div class="header">
        <span class="tip">已赞赏<span><a href="/u/1253528474">RickAi</a><span class="reward-amount">元</span>
      </div>
      <div class="line-sperator"></div>
      <div class="xzl-button-set share-topic-tip xzl-button-set--vertical">
        分享这篇超棒的文章
      </div>
      <div class="share-btns" data-title="从源码角度看Handler https://xiaozhuanlan.com/topic/9423185607">
        <div class="share-to-weibo ssb-icon ssb-weibo"  data-site="weibo"  onclick="return SocialShareButton.share(this);">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="19px" viewBox="0 0 22 19" version="1.1" class="share-to-weibo-logo">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="&#20999;&#22270;" stroke="none" stroke-width="1" fill-rule="evenodd">
        <g transform="translate(-204.000000, -229.000000)" id="icon_mine_weibo" fill="#FF636C">
            <g transform="translate(204.000000, 229.000000)">
                <path d="M8.682,19.0015 C4.414,19.0015 0,16.813 0,13.1495 C0,11.311 1.0825,9.18 3.0485,7.1505 C4.9335,5.2065 7.08,3.9985 8.6505,3.9985 C9.277,3.9985 9.8005,4.1975 10.1655,4.5745 C10.5325,4.9525 10.884,5.654 10.6315,6.9015 C11.564,6.536 12.4405,6.3435 13.185,6.3435 C14.3855,6.3435 14.9715,6.8355 15.2505,7.2475 C15.6545,7.8425 15.6855,8.628 15.345,9.5845 C17.019,10.137 18.014,11.3335 18.014,12.796 C18.014,15.731 14.1815,19.0015 8.682,19.0015 L8.682,19.0015 Z M8.6505,4.9985 C7.3805,4.9985 5.418,6.143 3.767,7.8465 C1.9825,9.688 1,11.5715 1,13.1495 C1,15.535 3.8735,18.0015 8.682,18.0015 C13.844,18.0015 17.014,14.97 17.014,12.796 C17.014,11.327 15.6035,10.7175 14.9975,10.523 C14.788,10.4585 14.4975,10.368 14.3525,10.0685 C14.2055,9.764 14.3255,9.4535 14.365,9.3515 C14.547,8.8775 14.7055,8.225 14.423,7.809 C14.1625,7.424 13.6055,7.3435 13.185,7.3435 C12.485,7.3435 11.6205,7.5575 10.6845,7.9615 C10.681,7.963 10.677,7.9645 10.6735,7.966 C10.548,8.019 10.3615,8.08 10.174,8.08 C9.8615,8.08 9.694,7.916 9.622,7.8175 C9.528,7.69 9.4385,7.466 9.5445,7.1255 C9.8005,6.276 9.7655,5.5985 9.4475,5.2705 C9.2725,5.0895 9.0045,4.9985 8.6505,4.9985 L8.6505,4.9985 Z M21.51,6 C21.234,6 21.01,5.7765 21.01,5.5 C21.01,3.0185 18.9915,1 16.51,1 C16.234,1 16.01,0.7765 16.01,0.5 C16.01,0.2235 16.234,0 16.51,0 C19.543,0 22.01,2.4675 22.01,5.5 C22.01,5.7765 21.7865,6 21.51,6 L21.51,6 Z M18.01,6 C17.734,6 17.51,5.7765 17.51,5.5 C17.51,4.949 17.0615,4.5 16.51,4.5 C16.234,4.5 16.01,4.2765 16.01,4 C16.01,3.7235 16.234,3.5 16.51,3.5 C17.613,3.5 18.51,4.397 18.51,5.5 C18.51,5.7765 18.2865,6 18.01,6 L18.01,6 Z" id="Shape-Copy-3"></path>
            </g>
        </g>
    </g>
</svg>

          <span>微博分享</span>
        </div>
        <div class="share-to-wechat">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20px" height="20px" viewBox="0 0 20 20" version="1.1" class="share-to-wechat-logo">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="&#20999;&#22270;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-152.000000, -229.000000)" id="icon_mine_wechat" fill="#02BB00">
            <g transform="translate(152.000000, 229.000000)">
                <g id="Group-25">
                    <path d="M1.0075,19.497 C0.8925,19.497 0.779,19.4575 0.6875,19.381 C0.5405,19.259 0.476,19.063 0.5215,18.8775 L1.7115,14.025 C0.591,12.533 0,10.8005 0,9 C0,4.038 4.486,0 10,0 C15.514,0 20,4.038 20,9 C20,13.9625 15.514,18 10,18 C8.644,18 7.3215,17.754 6.065,17.268 L1.2125,19.453 C1.147,19.482 1.077,19.497 1.0075,19.497 L1.0075,19.497 Z M10,1 C5.0375,1 1,4.589 1,9 C1,10.652 1.5695,12.2425 2.646,13.6 C2.742,13.7205 2.777,13.879 2.74,14.0295 L1.7375,18.12 L5.8475,16.269 C5.9725,16.2125 6.116,16.21 6.242,16.262 C7.4375,16.7515 8.7015,17 10,17 C14.9625,17 19,13.4115 19,9 C19,4.589 14.9625,1 10,1 L10,1 Z M6.5,6.4985 C7.0525,6.4985 7.5,6.946 7.5,7.4985 C7.5,8.051 7.0525,8.4985 6.5,8.4985 C5.9475,8.4985 5.5,8.051 5.5,7.4985 C5.5,6.946 5.9475,6.4985 6.5,6.4985 L6.5,6.4985 Z M13.5,6.4985 C14.0525,6.4985 14.5,6.946 14.5,7.4985 C14.5,8.051 14.0525,8.4985 13.5,8.4985 C12.9475,8.4985 12.5,8.051 12.5,7.4985 C12.5,6.946 12.9475,6.4985 13.5,6.4985 L13.5,6.4985 Z" id="Shape-Copy-4"></path>
                </g>
            </g>
        </g>
    </g>
</svg>

          <span>微信扫一扫</span>
          <div class="wechat-qrcode-img" data-url="https://xiaozhuanlan.com/topic/9423185607"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">
  $(".wechat-pay-success-modal .close").click(function(){
    $(".wechat-pay-success-modal").addClass("hidden")
    Turbolinks.visit(window.location.href)
  })

  $(".share-to-wechat").hover(function(){
    //$('.share-to-wechat .wechat-qrcode-img').
    $('.share-to-wechat .wechat-qrcode-img').fadeIn()
  })

  $(".share-to-wechat").mouseleave(function(){
    $('.share-to-wechat .wechat-qrcode-img').fadeOut()
  })
</script>

    <div class="overlay topic-reprint-modal hidden overlay--dark">
  <div class="overlay-dialog overlay-dialog--signin overlay-dialog--animate js-overlayDialog"
  tabindex="-1">
    <div class="close">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="16px" viewBox="0 0 16 16" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-273.000000, -154.000000)" id="icon_close_2" fill="#818181">
            <path d="M281,160.59766 L274.691197,154.288858 C274.296436,153.894097 273.674377,153.899886 273.287131,154.287131 C272.897186,154.677077 272.900659,155.302999 273.288858,155.691197 L279.59766,162 L273.288858,168.308803 C272.894097,168.703564 272.899886,169.325623 273.287131,169.712869 C273.677077,170.102814 274.302999,170.099341 274.691197,169.711142 L281,163.40234 L287.308803,169.711142 C287.703564,170.105903 288.325623,170.100114 288.712869,169.712869 C289.102814,169.322923 289.099341,168.697001 288.711142,168.308803 L282.40234,162 L288.711142,155.691197 C289.105903,155.296436 289.100114,154.674377 288.712869,154.287131 C288.322923,153.897186 287.697001,153.900659 287.308803,154.288858 L281,160.59766 Z"></path>
        </g>
    </g>
</svg>

    </div>
    <div class="overlay-actions">
      <div class="reprint-body">
        <div class="reprint-body-item reprint-topic-title-item">
          <span class="user-tip-label">转载文章</span>
          <span class="reprint-topic-title">从源码角度看Handler</span>
        </div>
        <div class="reprint-price reprint-body-item">
          <span class="user-tip-label">转载费用</span>
          <div class='prices'>
            <span class="number">180</span><span class="presion-number">.00</span>元
          </div>
        </div>
        <div class="reprint-address-div reprint-body-item">
          <span class="user-tip-label">转载到</span>
          <div class='custom-address-div'>
            <input class="custom-address-input" placeholder="请填写你要转载的网站/公众号/纸媒等地址" />
          </div>
        </div>
        <div class="pay-way reprint-body-item">
          <span class="user-tip-label">支付方式</span>
          <div class="wechat-pay-way pay-way-button">
            <img class="wechat-pay-logo" src="https://diycode.b0.upaiyun.com/assets/svgs/wechat-e7cc39b856533cdc49437c7235aa3a12525480633f79fb7d9164005112ae4d90.svg" alt="Wechat" />
            <span class='tip'>微信支付</span>
          </div>
        </div>
        <div class="reprint-notice reprint-body-item">
          <span class="user-tip-label">转载须知</span>
          <div class="notice topic-notice-item">
            <input id="topic-notice-item" type="checkbox" checked="true" />
            <label for="topic-notice-item"></label>
            <span class="reprint-notice-link"><a href="#">《转载协议》</a></span>
          </div>
        </div>
      </div>
      <div class="reprint-footer">
        <button class="button button--small reprint-pay-confirm-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" data-topic-id=6932>
          <span class="button-label  xzl-default-state-btn ">
            确认支付
          </span>
        </button>
      </div>
    </div>
  </div>
</div>
<div class="qrcode-for-reprint">
</div>
<script type="text/javascript">
  $(".topic-reprint-modal .close").click(function(){
    $(".topic-reprint-modal").addClass("hidden")
  })
</script>


          </div>
        </div>
      </section>
    </div>
  </article>
</div>
<script id="article-image-template" type="text/x-handlebars-template"><div class="ImageView" onclick="articleImageFloatClose()"><div class="ImageView-inner"> <img src='@img' /></div></div></script>
<div class='back-to-top'>
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="19px" height="11px" viewBox="0 0 19 11" version="1.1">
    <!-- Generator: Sketch 45.2 (43514) - http://www.bohemiancoding.com/sketch -->
    <title>top</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="A-首页-更改" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="B-文章详情-04" transform="translate(-1120.000000, -1149.000000)" stroke="#979797">
            <polyline id="top" transform="translate(1129.949747, 1158.949747) rotate(-315.000000) translate(-1129.949747, -1158.949747) " points="1123.62132 1165.27817 1123.62132 1152.62132 1123.62132 1152.62132 1136.27817 1152.62132"></polyline>
        </g>
    </g>
</svg>

</div>

<script type="text/javascript">
  $(".back-to-top").css({left: $(".xzl-home-containner").width() + $(".xzl-home-containner").offset().left + 50 + "px"})
  $(".back-to-top").click(function(){
    $("html, body").animate({
            scrollTop: 0
        }, 600);
  })
  $(window).scroll(function () {
      if ($(this).scrollTop() > 100) {
          $('.back-to-top').fadeIn();
      } else {
          $('.back-to-top').fadeOut();
      }
  });
</script>
<script type="text/javascript">
  
  setTimeout(function(){
    window.app.updateFrameHeight()
  }, 500)
  setTimeout(function(){
    window.app.fetch(window.location.href + "/visit", "get", {}, function(){}, false)
  }, 1500)


   var data = {}

    var contentTopic = document.getElementById("xzl-topic-content");

    contentTopic.innerHTML = (new window.Markdowner).getHtml();
    data["draft_html"] = $("#xzl-topic-content").html()

    var topicBody = document.getElementById("xzl-topic-body-content");
    if(topicBody){
      topicBody.innerHTML = (new window.Markdowner).getBodyHtml();
      if(!!topicBody.innerHTML){
        data["body_html"] = $("#xzl-topic-body-content").html()
      }
      var summaryHtml = document.getElementById("xzl-topic-summary-content");
      summaryHtml.innerHTML = (new window.Markdowner).getSumarryHtml();
      data["summary_html"] = $("#xzl-topic-summary-content").html()
      $("pre code").each(function(){
        $(this).html("<ul><li><div class='code_line'>" + $(this).html().replace(/\n/g,"\n</div></li><li><div class='code_line'>") +"\n</div></li></ul>");
      });
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
      //MathJax.Hub.Queue(["Typeset",MathJax.Hub, function(){
      if(!!$(".topic-body").data("enable-update-html")){
        data["update_token"] = $(".topic-body").data("update-token")
        $.ajax({
          url: $(".topic-body").data("url"),
          method: "put",
          data: data
        }).done(function(){
          summaryHtml.innerHTML = ""
          topicBody.innerHTML   = ""
        })
      }
      (new window.Markdowner).formatChartFromCode()
      //}]);
      // $(".hidden_topic_body").remove()
    }
</script>


    </div>
  </div>
    <div class="xzl-invite-card">
  <div class="share-logos">
    <div class="share-logo">
      <div class="share-tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="21px" height="17px" viewBox="0 0 21 17" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title></title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-468.000000, -514.000000)" id="icon_1_wechat" fill="#02BB00">
            <g transform="translate(468.000000, 514.000000)">
                <path d="M17,11 C16.4444444,11 16,10.5555556 16,10 C16,9.44444444 16.4444444,9 17,9 C17.5555556,9 18,9.44444444 18,10 C18,10.5277778 17.5555556,11 17,11 M12,11 C11.4444444,11 11,10.5555556 11,10 C11,9.44444444 11.4444444,9 12,9 C12.5555556,9 13,9.44444444 13,10 C13,10.5277778 12.5555556,11 12,11 M18.7527881,15.1010526 C20.1301115,14.1515789 21,12.7389474 21,11.1873684 C21,8.31578947 18.1003717,6 14.5,6 C10.8996283,6 8,8.31578947 8,11.1873684 C8,14.0589474 10.8996283,16.3747368 14.5,16.3747368 C15.2490706,16.3747368 15.9498141,16.2821053 16.6263941,16.0968421 C16.6747212,16.0736842 16.7472119,16.0736842 16.8197026,16.0736842 C16.9405204,16.0736842 17.0613383,16.12 17.1579926,16.1663158 L18.5836431,16.9536842 C18.6319703,16.9768421 18.6561338,17 18.704461,17 C18.8252788,17 18.9219331,16.9073684 18.9219331,16.7915789 C18.9219331,16.7452632 18.8977695,16.6989474 18.8977695,16.6294737 C18.8977695,16.6063158 18.704461,15.9810526 18.6078067,15.5873684 C18.5836431,15.5410526 18.5836431,15.4947368 18.5836431,15.4484211 C18.5594796,15.2863158 18.6319703,15.1705263 18.7527881,15.1010526" id="Shape-Copy"></path>
                <path d="M10,5.12844037 C9.45547362,5.12844037 9.02439024,4.70684873 9.02439024,4.17431193 C9.02439024,3.64177512 9.45547362,3.22018349 10,3.22018349 C10.5445264,3.22018349 10.9756098,3.64177512 10.9756098,4.17431193 C10.9756098,4.6846597 10.5445264,5.12844037 10,5.12844037 M5,5.12844037 C4.45547362,5.12844037 4.02439024,4.70684873 4.02439024,4.17431193 C4.02439024,3.64177512 4.45547362,3.22018349 5,3.22018349 C5.54452638,3.22018349 5.97560976,3.64177512 5.97560976,4.17431193 C5.97560976,4.6846597 5.54452638,5.12844037 5,5.12844037 M0,6.13508772 C0,7.98245614 1.00624025,9.64736842 2.62090484,10.7649123 C2.73790952,10.8561404 2.83151326,10.9929825 2.83151326,11.1754386 C2.83151326,11.2210526 2.80811232,11.2894737 2.80811232,11.3350877 C2.69110764,11.7912281 2.48049922,12.5438596 2.45709828,12.5666667 C2.43369735,12.6350877 2.41029641,12.6807018 2.41029641,12.7491228 C2.41029641,12.8859649 2.52730109,13 2.66770671,13 C2.71450858,13 2.76131045,12.977193 2.80811232,12.954386 L4.46957878,12.0192982 C4.58658346,11.9508772 4.72698908,11.9052632 4.8673947,11.9052632 C4.9375975,11.9052632 5.00780031,11.9052632 5.07800312,11.9280702 C5.85023401,12.1333333 6.69266771,12.2701754 7.5351014,12.2701754 L7.95631825,12.2701754 C7.7925117,11.7912281 7.69890796,11.2894737 7.69890796,10.7649123 C7.69890796,7.68596491 10.7878315,5.17719298 14.5787832,5.17719298 L15,5.17719298 C14.4617785,2.23508772 11.326053,0 7.55850234,0 C3.39313573,0 0,2.73684211 0,6.13508772 Z" id="Shape-Copy-2"></path>
            </g>
        </g>
    </g>
</svg>
<span>微信扫码</span></div>
      <div class="wechat-qrcode-img" data-url="https://xiaozhuanlan.com/topic/9423185607"></div>
    </div>
    <div class='line-speartor'></div>
    <div class="share-logo social-share-button" data-title="向大家推荐《从源码角度看Handler》
 https://xiaozhuanlan.com/topic/9423185607">

      <div class="share-tip" data-title="向大家推荐《从源码角度看Handler》
 https://xiaozhuanlan.com/topic/9423185607" ><a rel="nofollow " data-site="weibo" class="ssb-icon ssb-weibo" onclick="return SocialShareButton.share(this);" title="Share to Twitter" href=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="19px" viewBox="0 0 24 19" version="1.1">
    <!-- Generator: Sketch 47.1 (45422) - http://www.bohemiancoding.com/sketch -->
    <title>icon_weibo_01@2x</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-786.000000, -75.000000)" id="icon_weibo_01" fill-rule="nonzero" fill="#F54E4C">
            <path d="M794.337934,85.2741341 C792.337079,85.5504873 790.899754,87.0989312 791.124877,88.7310747 C791.350722,90.3632182 793.155315,91.4628586 795.15617,91.1865054 C797.155582,90.9101522 798.595072,89.3617084 798.369227,87.7281218 C798.144104,86.0959783 796.338789,84.9970594 794.337934,85.2741341 Z M793.754201,89.8855528 C793.050691,89.9829619 792.417171,89.5969333 792.337079,89.0225804 C792.25843,88.4496706 792.763514,87.9056228 793.467024,87.8074921 C794.169813,87.7108046 794.804054,88.0968332 794.884146,88.6711861 C794.962795,89.2448174 794.456989,89.7881437 793.754201,89.8855528 Z M795.547971,88.0391093 C795.252858,88.1141504 794.963517,87.9792208 794.903628,87.7382234 C794.842297,87.4972261 795.032064,87.2417978 795.327177,87.1674783 C795.622291,87.0931588 795.910189,87.2273669 795.97152,87.4683642 C796.033574,87.7093615 795.841642,87.9655113 795.547971,88.0391093 Z M804.723908,82.5676044 C804.827811,82.6116188 804.936765,82.6325437 805.043554,82.6325437 C805.3632,82.6325437 805.668416,82.4442195 805.80118,82.1303457 C805.954149,81.7695713 806.031355,81.3849858 806.031355,80.989577 C806.031355,79.3740291 804.717414,78.0593671 803.101866,78.0593671 C802.707179,78.0593671 802.323315,78.1365729 801.961098,78.2895412 C801.542599,78.4670422 801.347059,78.9497584 801.523839,79.3675352 C801.70134,79.7860335 802.184056,79.9822948 802.602554,79.8055153 C802.760574,79.7391329 802.928695,79.7052201 803.101866,79.7052201 C803.809706,79.7052201 804.386223,80.281016 804.386223,80.989577 C804.386223,81.1641918 804.353032,81.3323127 804.286649,81.4896104 C804.109148,81.9073872 804.30541,82.3908249 804.723908,82.5676044 Z M802.808196,83.780528 C802.889009,83.5489108 802.969101,83.3201798 802.969101,83.3201798 C804.409313,80.5559262 800.696222,79.6547116 798.566932,80.8293932 C796.438363,82.0055178 797.465848,80.0154861 797.465848,80.0154861 C797.817964,76.3810445 793.997363,77.9893769 793.997363,77.9893769 C785.124477,82.9651778 786.025691,87.8962426 786.025691,87.8962426 C786.025691,90.6099878 790.279943,93.640493 795.64538,93.640493 C802.753358,93.640493 806.806298,89.4850932 806.102066,86.3968641 C805.817055,85.1500277 804.336436,84.0814138 802.808196,83.780528 Z M794.588311,92.2291435 C789.934321,92.2291435 788.359902,89.8083471 788.359902,88.0585911 C788.359902,85.2864004 792.032585,83.2386448 795.490247,83.2386448 C798.947188,83.2386448 801.411277,84.7077183 801.975528,86.6342537 C802.811082,89.4850932 799.16726,92.2291435 794.588311,92.2291435 Z M803.101866,75 C802.594617,75 802.088812,75.0642178 801.601045,75.1904889 C801.161621,75.3037721 800.896813,75.7525755 801.010096,76.1927203 C801.124822,76.6321435 801.572904,76.8969519 802.012327,76.7836688 C802.365886,76.6913105 802.732433,76.6458529 803.102588,76.6458529 C805.496687,76.6458529 807.44559,78.5947564 807.44559,80.9888555 C807.44559,81.5025982 807.356118,82.0047962 807.182947,82.4802969 C807.027092,82.9067323 807.246443,83.3800684 807.672878,83.5352014 C807.765958,83.5691142 807.861202,83.5857098 807.955004,83.5857098 C808.290524,83.5857098 808.606562,83.3779037 808.727783,83.0445481 C808.967337,82.3872171 809.09,81.6952518 809.09,80.9881339 C809.089279,77.6870479 806.403674,75 803.101866,75 Z"></path>
        </g>
    </g>
</svg>
<span>新浪微博</span></a></div>
      <div class="share-tip" data-title="向大家推荐《从源码角度看Handler》
 https://xiaozhuanlan.com/topic/9423185607" ><a rel="nofollow " data-site="twitter" class="ssb-icon ssb-twitter" onclick="return SocialShareButton.share(this);" title="Share to Twitter" href=""><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="21px" height="18px" viewBox="0 0 21 18" version="1.1">
    <!-- Generator: Sketch 47.1 (45422) - http://www.bohemiancoding.com/sketch -->
    <title>icon_twitter@2x</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-722.000000, -74.000000)" id="icon_twitter" fill-rule="nonzero" fill="#1296DB">
            <g transform="translate(722.000000, 74.000000)">
                <path d="M14.2831702,0.00104702329 C15.9524708,-0.0287932359 16.8416087,0.582932296 17.6886425,1.3587793 C18.4093643,1.29661208 19.3430829,0.891281729 19.8953886,0.612772555 C20.0737115,0.513304984 20.2520344,0.416324117 20.4303574,0.316856546 C20.1158155,1.17227761 19.6873452,1.83871032 19.0334945,2.34848158 C18.8873688,2.4603826 18.7437198,2.61207062 18.5604435,2.68418461 L18.5604435,2.69413138 C19.4941621,2.68418464 20.2668947,2.26144748 21,2.03018537 L21,2.04013212 C20.6161104,2.65434433 20.0935252,3.27601663 19.5387428,3.72362069 C19.3133624,3.90266232 19.0904588,4.08170392 18.8650784,4.26074555 C18.877462,5.25542121 18.8502182,6.20284978 18.6644651,7.03837733 C17.5895743,11.8948813 14.7388843,15.1897444 10.2263239,16.6021838 C8.60655738,17.1094684 5.98620119,17.3158636 4.13114753,16.8533394 C3.20981246,16.624564 2.37763887,16.3659483 1.59747612,16.0227852 C1.16405237,15.8313102 0.762825805,15.624915 0.378936204,15.3911662 L0,15.1599041 C0.418563521,15.1723376 0.908951532,15.2892119 1.37704919,15.2121246 C1.8005661,15.1424973 2.2166529,15.1623908 2.60549592,15.0753567 C3.58131855,14.8615014 4.44568934,14.5780188 5.19117821,14.1403616 C5.55277746,13.928993 6.10012974,13.6778374 6.35770728,13.3719746 C5.87474938,13.3794347 5.43389551,13.2675337 5.07477296,13.1407125 C3.68038684,12.6458614 2.8705036,11.7382198 2.34296497,10.3730275 C2.76648189,10.4177879 3.98254511,10.5296889 4.26736644,10.2884801 C3.73487439,10.2586398 3.22467272,9.95029034 2.85812006,9.72151494 C1.73617171,9.01778191 0.82226678,7.83660455 0.829696899,6.01883477 C0.978299323,6.08846205 1.12442505,6.15808937 1.27055078,6.22771665 C1.55289539,6.34707774 1.83771672,6.41173164 2.17454889,6.47887227 C2.31572119,6.50871253 2.60054253,6.59325997 2.76400519,6.53109275 L2.74171483,6.53109275 C2.52624131,6.27745045 2.17207219,6.10835559 1.95412195,5.83730646 C1.23587688,4.93961166 0.559735827,3.55701251 0.988206164,1.91331097 C1.09718127,1.4955472 1.26807408,1.1275172 1.4513504,0.786840798 C1.45878052,0.789327478 1.46621064,0.794300863 1.47116406,0.796787543 C1.55537211,0.973342466 1.74112513,1.10265032 1.86000708,1.24936496 C2.22903644,1.70691576 2.67979716,2.11721947 3.14294139,2.48027611 C4.71565044,3.71864731 6.13232692,4.4770875 8.4059441,5.03907926 C8.98301686,5.18082054 9.64925109,5.29023485 10.3402524,5.29272153 C10.1470692,4.72575642 10.2089869,3.81065479 10.360066,3.2610965 C10.7439556,1.88347071 11.5761293,0.891281729 12.7996226,0.356643575 C13.0918741,0.229822424 13.4163227,0.137814918 13.7556316,0.0632142461 C13.9314778,0.0433207319 14.107324,0.0209405375 14.2831702,0.00104702329" id="Shape"></path>
            </g>
        </g>
    </g>
</svg>
<span>Twitter</span></a></div>
    </div>
  </div>
  <div class="popover-arrow down">
  </div>
</div>

<script type="text/javascript">
  $(".topic-share-btn-item").hover(function(){
  $(".xzl-invite-card").css({"top": $(".topic-share-btn").offset().top - 200, "left": $(".topic-share-btn").offset().left - 175})
    $(".xzl-invite-card").addClass("hovering-logo")
    $(".xzl-invite-card").show()
  })
  $(".xzl-invite-card").hover(function(){
    $(".xzl-invite-card").addClass("hovering-card")
    $(".xzl-invite-card").show()
  })

  var checkoutFoucs = function(){
    if(!$(".xzl-invite-card").hasClass("hovering-logo")){
      if(!$(".xzl-invite-card").hasClass("hovering-card")){
        $(".xzl-invite-card").hide()
      }
    }
  }

  $(".xzl-invite-card").mouseleave(function(){
    $(".xzl-invite-card").removeClass("hovering-card")
    setTimeout(checkoutFoucs, 500)
  })

  $(".topic-share-btn-item").mouseleave(function(){
    $(".xzl-invite-card").removeClass("hovering-logo")
    setTimeout(checkoutFoucs, 500)
  })
   $(".wechat-qrcode-img").qrcode({
    render: "canvas",
    text: $(".wechat-qrcode-img").data("url"),
    height: 70,
    width: 70,
  })

</script>
  
</body>

<script type="text/javascript">
  $(document).ready(function(){
    $("abbr.timeago").timeago()
    window.Photo.initUserAvatarDropzone()
    window.Photo.browseUpload(".user-avatar-edit")
    window.Photo.initPhotoDropzone("zhuanlan-logo", ".zhuanlan-logo-img")
    window.Photo.browsePhotoUpload("zhuanlan-logo")

    $(".buttonSwitch button").click(function(){
      if($(this).parent().hasClass("uneditable")){
        return
      }
      var siblings = $(this).siblings()
      siblings.each(function(index){
        $(siblings[index]).removeClass("selected")
      })
      $(this).addClass("selected")
    })
    Turbolinks.start()
  })
  window.user.init()
</script>

  <script type="text/javascript">
    // $("html, body").animate({
    //     scrollTop: 0
    // }, 600);
    var resize  = function(){
      var width = $(window).width()
      if (width > 730){
         $(".xzl-topic-item .topic-body .topic-cover-wrapper, .xzl-topic-item .topic-body .topic-cover-wrapper .topic-cover-div").css("height", 180 + "px")
      }else{  
        var height = 180*(width - 40)/670
        $(".xzl-topic-item .topic-body .topic-cover-wrapper, .xzl-topic-item .topic-body .topic-cover-wrapper .topic-cover-div").css("height", height + "px")
      }

      if(width > 1340){
        $(".topic-editor-dropzone.dz-clickable, .navbar.navbar-default, .cmmde_title, .topic-cover-dropzone.dz-clickable").css({"width": "670px"})
      }else{
        var maxWidth = ($(window).width() - 80) /2 
        $(".topic-editor-dropzone.dz-clickable, .navbar.navbar-default, .cmmde_title, .topic-cover-dropzone.dz-clickable").css({"width": maxWidth + "px"})
      }
    }
    window.onresize = resize;
    resize()
    window.followUserHover = function(){
      $(".btn-follow-user").unbind("hover")
      $(".btn-follow-user").unbind("mouseleave")
      $(".btn-follow-user.followed").hover(function(){
        if($(this).hasClass("followed")){
          $(this).find("span").text("取消关注")
        }
      })
      $(".btn-follow-user.followed").mouseleave(function(){
        $(this).find("span").text("已关注")
      })
    }
    window.followUserHover()

  </script>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-102672567-1', 'auto');
    ga('send', 'pageview');

  </script>

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e7fbc901596776745c59d839ad5b5ef7";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>

  
</html>

